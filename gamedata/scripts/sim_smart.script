--[[ -----------------------------------
 #  Управление смартами
 #  for Lost Path
 # 	based on Eoc by xrSanya
 #  author : b4d1k
 #  date   : 14.01.2018
 #  file   : sim_smart.script 
]]-- -----------------------------------

smart_ids = {}

smart_owners = {}
hide_sim = false
config = ini_file_ex("settings\\faction_commander_setting.ltx",true)

local smarts = (lostpath_main.config:r_value("map","enable_show_smart",1))

local default_pop   = (lostpath_main.config:r_value("smart_population","default_pop",2))
local lair_pop      = (lostpath_main.config:r_value("smart_population","lair_pop",2))
local base_pop      = (lostpath_main.config:r_value("smart_population","base_pop",2))
local res_pop       = (lostpath_main.config:r_value("smart_population","res_pop",2))
local territory_pop = (lostpath_main.config:r_value("smart_population","territory_pop",2))

local spawn_attack_time = (lostpath_main.config:r_value("war_options","spawn_attack_time",2))
local spawn_defence_time = (lostpath_main.config:r_value("war_options","spawn_defence_time",2))
local spawn_mutant_time = (lostpath_main.config:r_value("war_options","spawn_mutant_time",2))
local capture_actor_news = (lostpath_main.config:r_value("scripts","enable_capture_actor_news",1))
local night_spawn = (lostpath_main.config:r_value("scripts","enable_night_spawn",1))

local endl = "\\n"
local tb = " "
local tbs = ", "
local dt = "."
local c1 = "«"
local c2 = "»"
local gs = game.translate_string

fc = ui_faction_commander.UIFactionCommander()
typ = fc:getValue("command")
typ_ai = fc:getValue("command_ai")

function set_max_population(smart)
	if (smart.props) then
	    smart.max_population = default_pop
		
	    if not smart.props.population then
			if smart.props.lair > 0 then
			   smart.max_population = lair_pop
			   
			elseif smart.props.base > 0 then		
			   smart.max_population = base_pop
			   
			elseif smart.props.territory > 0 then
				smart.max_population = territory_pop
				
			elseif smart.props.resource > 0 then
				smart.max_population = res_pop
			end
		else
			smart.max_population = smart.props.population
		end
	end
end

function smart_terrain_on_update(smart)
	--printf("%s", smart:name())
	local curr_time = game.get_game_time()
	smart.last_respawn_update = curr_time

	if not (smart.level_id) then
		smart.level_id = game_graph():vertex(smart.m_game_vertex_id):level_id()
	end
	
	if not (smart.first_update) then
		smart.first_update = true		
		
		set_max_population(smart)	
		
		if (smart_owners[smart.id]) then
			smart.owning_faction = smart_owners[smart.id]
		end
			
		local offset = sim_tables.level_offsets[smart.level_id]
		local p = smart.position
		
		if (offset) then
			smart.global_position = vector():set(p.x + offset[1], p.y + offset[2], p.z + offset[3])
		end
		----printf("%s", smart:name())
		smart_ids[smart:name()] = smart.id
		
		if not smart.updating_squad then
			smart.updating_squad = {}
		end
	end
	
	local squads = SIMBOARD.smarts[smart.id].squads
	
	for i,squad in pairs(squads) do
		local faction = squad:get_squad_community()
		
		if squad.smart_id == smart.id and smart.owning_faction == "none" and squad:get_squad_community() ~= "trader" and squad:get_squad_community() ~= "monster" and not squad.registered_in_simultaion then
			
			if not (squad.registered_in_simultaion) then	
				squad.checked_register = true

				if sim_tables.registered_squads[faction] then
				
					if not sim_tables.registered_squads[faction][squad.id] then
						sim_tables.registered_squads[faction][squad.id] = smart.id
					end
					
					squad.registered_in_simultaion = true
				end
				
				----printf("squad name %s registered in simultaion", squad:name())
			end
			
			----printf("check owner %s on %s", smart.owning_faction, sim_script_to_text.smart_names[smart:name()])
			smart.owning_faction = squad:get_squad_community() 
			----printf("%s %s %s %s %s", smart.owning_faction, squad:get_squad_community(), squad.registered_in_simultaion, sim_tables.registered_squads[faction], sim_tables.registered_squads[faction][squad.id])
		end
		
		if ((squad.current_action == 1 or squad.combat_action == 1) and squad.registered_in_simultaion) then			
			local power = sim_offline_control.ocs_power_table[squad.id]
			
			if power and power > 0 and sim_factions.faction_information[faction] then
				sim_factions.faction_information[faction].total_power = sim_factions.faction_information[faction].total_power + math.ceil(power/50)
			end
		end
	end
	
	if npc_count(smart, smart.owning_faction) == 0 then
		smart.owning_faction = "none"
	end
	
	check_owner(smart)
	show_smart(smart)
	
	local text = sim_text.targeting
	
	if smart.squad and smart.waiting_for_squad and smart.squad:npc_count() == 0 then
		local script_to_text_smart = sim_script_to_text.smart_names[smart:name()] or smart:name()
		db.actor:give_game_news(gs("sim_smart_targeting_4"), (gs("sim_smart_targeting_5") .. tb .. script_to_text_smart .. tb .. gs("sim_smart_targeting_6")), sim_offline_to_online.getSenderIcon(sim_brain.actor_faction), 0, 15000)
		newtarget_manual_capture(smart)
	end
	
	if not (smart.target_smart_count) then
		smart.target_smart_count = 0
	end
	
	if not (sim_brain.initialized) then
		return
	end
	
	local faction = smart.owning_faction
	local dist = alife():actor().position:distance_to_sqr(smart.position)
	
	local sim = alife()
	local gg = game_graph()
	local al = sim:level_name(gg:vertex(sim:actor().m_game_vertex_id):level_id())
	local sl = sim:level_name(gg:vertex(smart.m_game_vertex_id):level_id())

	if smart.props then	
	    process_mutants(smart)
		if dist > 5000 and al == sl or al ~= sl then
	        smart_control(smart)
			
		    if smart.props.base > 0 then
			    if faction == "none" then
			        try_to_respawn_faction(smart)
				end
			end
			
			if smart.props.base <= 0 and faction == "none" then
				spawn_mutants(smart)
			end
			
			if smart.props.lair > 0 then 			   
		       spawn_mutants(smart)
			end
		elseif dist < 5000 and al == sl then
		    if smart.props.base > 0 or smart.props.resource > 0 then
				target_manual_capture(smart)
			end	   
	    end
		
		if smart.props.base > 0 and faction ~= "none" and faction ~= "trader" and 
		((dist > 5000 and faction ~= sim_brain.actor_faction and game_relations.is_factions_enemies(sim_brain.actor_faction, faction)) or not(game_relations.is_factions_enemies(sim_brain.actor_faction, faction) or game_relations.is_factions_friends(sim_brain.actor_faction, faction))) then
			if sim_brain.brain[faction].rush > 0 and sim_brain.brain[faction].no_spawn ~= 1 then
				spawn_attack_squad(smart, true)
			elseif sim_brain.brain[faction].no_spawn ~= 1 then
				spawn_attack_squad(smart, false)
			end
			
			if faction ~= "zombied" then check_npc(smart) end
		end
		
		if smart.props.base > 0 and faction ~= "none" and faction ~= "trader" and 
		((--[[dist > 5000 and]] faction ~= sim_brain.actor_faction and game_relations.is_factions_enemies(sim_brain.actor_faction, faction)) or not(game_relations.is_factions_enemies(sim_brain.actor_faction, faction) or game_relations.is_factions_friends(sim_brain.actor_faction, faction))) then
			if sim_brain.brain[faction].no_spawn ~= 1 then
				if sim_brain.brain[faction].no_spawn ~= 1 then
					spawn_defense_squad(smart)	
				end
			end
		end	
	end	
end

function try_to_respawn_faction(smart)
	
    local smart_level = alife():level_name(game_graph():vertex(smart.m_game_vertex_id):level_id())
	
	for i,faction in pairs(sim_tables.factions) do 
		if faction ~= "monster" then
		    if (sim_factions.faction_information[faction].base_count) and sim_factions.faction_information[faction].base_count < 1 then		
		        local level_chk = sim_brain.allowed_respawn(smart_level, faction)
				
		        if level_chk == true then
				   sim_factions.faction_information[faction].base_count = sim_factions.faction_information[faction].base_count + 1
				   sim_squad.create_squad(smart, faction, nil, nil, nil, 1)
				   break
				end
		    end
		end
	end
end

function check_npc(smart)
	
	local faction = smart.owning_faction
	local trader = faction .. "_sim_squad_trader"
	local mechanic = faction .. "_sim_squad_mechanic"
	local medik = faction .. "_sim_squad_medik"
	local leader = faction .. "_sim_squad_leader"

	local trader_pop = 1
	local mechanic_pop = 1
	local barmen_pop = 1
	local medik_pop = 1
	local leader_pop = 1

	local mechanic_in_smart = 0
	local trader_in_smart = 0
	local medik_in_smart = 0
	local leader_in_smart = 0
	
			
	local squads = SIMBOARD.smarts[smart.id].squads
	
	for i,s in pairs(squads) do			
		if string.find(s:name(), "mechanic") or string.find(s:name(), "tech") or string.find(s:name(), "drunk") then				
		   mechanic_in_smart = mechanic_in_smart + 1
		end
		   
		if string.find(s:name(), "trader") or string.find(s:name(), "petrenko") then
		   trader_in_smart = trader_in_smart + 1
		end
		
		if string.find(s:name(), "medik") or string.find(s:name(), "medic") or string.find(s:name(), "doctor") then
		   medik_in_smart = medik_in_smart + 1
		end
		
		if string.find(s:name(), "leader") then
		    leader_in_smart = leader_in_smart + 1
		end		
	end
	
	local smart_limit = npc_count(smart, smart.owning_faction)
	
	if(smart.props.base > 0) then
		while mechanic_in_smart < mechanic_pop do	
			sim_squad.create_squad(smart, faction, nil, mechanic , nil, 1)
			mechanic_in_smart = mechanic_in_smart + 1
			----printf("### EOC: Спавн механика в смарт ".. smart:name() .." ###")
		end
		   
		while trader_in_smart < trader_pop do
			sim_squad.create_squad(smart, faction, nil, trader, nil, 1)
			trader_in_smart = trader_in_smart + 1
			----printf("### EOC: Спавн торговца в смарт ".. smart:name() .." ###")
		end

		while medik_in_smart < medik_pop do
			sim_squad.create_squad(smart, faction, nil, medik, nil, 1)
			medik_in_smart = medik_in_smart + 1
			----printf("### EOC: Спавн медика в смарт ".. smart:name() .." ###")
		end	
		
		while leader_in_smart < leader_pop do
			sim_squad.create_squad(smart, faction, nil, leader, nil, 1)
			leader_in_smart = leader_in_smart + 1
			----printf("### EOC: Спавн наставника в смарт ".. smart:name() .." ###")
		end	
	end
end

function newtarget_manual_capture(smart)
	local levels = game_graph():vertex(smart.m_game_vertex_id):level_id()
	local linked = sim_tables.level_links[levels]	
	local currentLevelSmarts = sim_levels.level_information[levels].smarts
	local smartCollection = {}
	
	--'----------------------------------------------------------------------------------
	--' Настройка спавна отрядов при захвате точек
	--'----------------------------------------------------------------------------------
	local faction = sim_brain.actor_faction
	local script_to_text_smart = sim_script_to_text.smart_names[smart:name()] or smart:name() 
	
	local tp = sim_factions.faction_information[faction].total_power
	local bot = 0
	local r = 1
	
	local nubmer = ""
	local p = "_"
	local section = "novice"
	
	if tp <= 1000 then
		section = "novice"
		r = 1
	elseif tp <= 3500 then
		section = "advanced"
		r = 2
	elseif tp > 3500 then
		section = "veteran"
		r = 3
	end
	
	if section == "novice" then
		bot = tp / 140
		bot = math.floor(bot)
	elseif section == "advanced" then
		bot = tp / 500
		bot = math.floor(bot)
	elseif section == "veteran" then
		bot = tp / 1000
		bot = math.floor(bot)
		if bot > 8 then bot = 8 end
	end
	
	if linked  == "1" and section == "veteran" then 
		section = "advanced"
	elseif linked  == "2" and section == "veteran" then 
		section = "advanced" 
	end
	
	number = tostring(bot)
	
	if nubmer ~= "" then
		type = faction .."_sim_squad_".. section ..p..number, smart:name()
	else
		type = faction .."_sim_squad_".. section, smart:name()
	end
	
	for i=1,#currentLevelSmarts	do
		smartCollection[#smartCollection+1] = currentLevelSmarts[i]
	end
	
	for lvl,_ in pairs(linked) do
		local smarts = sim_levels.level_information[lvl].smarts
		
		for i=1,#smarts do			    
		    smartCollection[#smartCollection+1] = smarts[i]
		end
	end
	
	for i=1,#smartCollection do
	    local spawn_smart = alife_object(smartCollection[i])
		
		if (spawn_smart) and (spawn_smart.props) and (spawn_smart.props.base > 0) then
		    if spawn_smart.owning_faction == faction then
				----printf("%s %s", spawn_smart.owning_faction, faction)
				local spawn_smart_name = sim_script_to_text.smart_names[spawn_smart:name()] or spawn_smart:name()
				smart.waiting_for_squad = true			   
				local squad = sim_squad.create_squad(spawn_smart, nil, smart, type, nil, 2)
				----printf("%s %s", squad, squad.id)
				smart.squad = squad
				local comnews = sim_script_to_text.faction_names_standart[sim_brain.actor_faction]
				
				local title = gs("sim_smart_capture_title") .. tb .. c1 .. comnews .. c2
				local sms = gs("sim_smart_capture_1") .. tb .. script_to_text_smart .. tb .. gs("sim_smart_capture_2") .. tb .. spawn_smart_name .. dt
				
				db.actor:give_game_news(title, sms, sim_offline_to_online.getSenderIcon(sim_brain.actor_faction), 0, 15000)
				break
			end
		end
	end
end

local sounds = {
	stalker = "characters_voice\\human_01\\stalker\\alife\\defence\\actor_help_1",
	csky = "characters_voice\\human_01\\csky\\alife\\defence\\actor_help_1",
	dolg = "characters_voice\\human_01\\dolg\\alife\\defence\\actor_help_1",
	freedom = "characters_voice\\human_01\\freedom\\alife\\defence\\actor_help_1",
	ecolog = "characters_voice\\human_01\\stalker\\alife\\defence\\actor_help_1",
	isg = "characters_voice\\human_01\\stalker\\alife\\defence\\actor_help_1",
	monolith = "characters_voice\\human_01\\monolith\\alife\\defence\\actor_help_1",
	darkstalker = "characters_voice\\human_01\\monolith\\alife\\defence\\actor_help_1",
	army = "characters_voice\\human_01\\military\\alife\\defence\\actor_help_1",
	bandit = "characters_voice\\human_01\\bandit\\alife\\defence\\actor_help_1",
	killer = "characters_voice\\human_01\\killer\\alife\\defence\\actor_help_1"
}

config = ini_file("rpg.ltx")
max_level = config:r_float_ex("settings", "max_rank")

function target_manual_capture(smart)

	if not(smart.online) then
		return
	end
	
	local tg = time_global()

	if smart.manual_capture ~= nil and tg < smart.manual_capture then
		return
	end

	smart.manual_capture = tg + 1000

	local script_to_text_smart = sim_script_to_text.smart_names[smart:name()] or smart:name() 
	local faction = sim_brain.actor_faction	
	
	local luck_bonus = config:r_float_ex("luck_bonus", db.actor:get_level_luck())
	local exp_for_up = 0
	
	if db.actor:get_level() < max_level then
		exp_for_up = config:r_float_ex("exp_for_up", db.actor:get_level() + 1)
	else
		exp_for_up = config:r_float_ex("exp_for_up", db.actor:get_level())
	end
	
	local exp_4_percent = math.floor(exp_for_up / 25)
	local exp_2_percent = math.floor(exp_for_up / 50)
	
	local targeting = gs("sim_smart_targeting")
	
	if (smart.waiting_for_squad) then
		if smart.owning_faction == faction then		
            local nagrada, rept, exp = 0, 0 ,0
		    if smart.props.base > 0 then
				nagrada = (3000 + math.random(0, 3000)) * (1 + (luck_bonus * 2)/100)
				rept = math.random(0, 50) * (1 + (luck_bonus * 2)/100)
				exp = math.random(1, exp_4_percent) * (1 + (luck_bonus * 2)/100)
				if capture_actor_news == true then
				db.actor:give_game_news(("Capture goal"), ("The base in ".. script_to_text_smart .." is captured, reward for the capture is  ".. nagrada .." and "..rept.." reputation."), sim_offline_to_online.getSenderIcon(sim_brain.actor_faction), 0, 15000)
				end
			elseif smart.props.resource > 0 then
				nagrada = (500 + math.random(0, 1000)) * (1 + (luck_bonus * 2)/100)
				rept = math.random(0, 15) * (1 + (luck_bonus * 2)/100)
				exp = math.random(1, exp_2_percent) * (1 + (luck_bonus * 2)/100)
				if capture_actor_news == true then
				db.actor:give_game_news(("Capture goal"), ("The resource point in ".. script_to_text_smart .." is captured, reward for the capture is  ".. nagrada .." and "..rept.." reputation."), sim_offline_to_online.getSenderIcon(sim_brain.actor_faction), 0, 15000)
				end
			end
		    SetHudMsg("Point captured!",5)
			db.actor:add_exp(exp)
			task_objects.smart_capture(nagrada, faction)
			xr_effects.inc_faction_goodwill_to_actor(db.actor, nil, {faction, rept}) 
			--xr_sound.set_sound_play(db.actor:id(), "pda_news")
			
			local play = sounds[faction]
			--store_table(sounds)
			----printf("%s %s", faction, play)
			
			local function play_sound(snd)
				if snd then
					local snd_obj = xr_sound.get_safe_sound_object(snd)
					snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vector(), 1.0)
				end
			end
			
			play_sound(play)
			
			smart.waiting_for_squad = nil
        else
            return		
	    end 
	end
	
	if smart.owning_faction ~= "none" then
	   return
	end
		
	local dist = smart.position:distance_to_sqr(alife():actor().position)
	
	if (dist > 2500 and smart.time_to_capture) then
	     smart.time_to_capture = nil
	     if smart.props.base > 0 and capture_actor_news == true then
			db.actor:give_game_news(("Capture goal"), ("You have stopped capturing a base in ".. script_to_text_smart), sim_offline_to_online.getSenderIcon(sim_brain.actor_faction), 0, 15000)
	     elseif smart.props.resource > 0 and capture_actor_news == true  then
			db.actor:give_game_news(("Capture goal"), ("You have stopped capturing a resource point in ".. script_to_text_smart), sim_offline_to_online.getSenderIcon(sim_brain.actor_faction), 0, 15000)
		 end
		 xr_sound.set_sound_play(db.actor:id(), "pda_news")
	end
	
	if (dist > 2500) then
	    if smart.uncaptured == true then
		   smart.uncaptured = nil
		end
	    return
	end
	
	if smart.uncaptured == true then
	   return
	end
			
	if not(smart.time_to_capture) then
	    smart.time_to_capture = 0
	    if smart.props.base > 0 and capture_actor_news == true  then
			db.actor:give_game_news(("Capture goal"), ("You captured the base in ".. script_to_text_smart), sim_offline_to_online.getSenderIcon(sim_brain.actor_faction), 0, 15000)
	    elseif smart.props.resource > 0 and capture_actor_news == true  then
			db.actor:give_game_news(("Capture goal"), ("You captured the resource point in ".. script_to_text_smart), sim_offline_to_online.getSenderIcon(sim_brain.actor_faction), 0, 15000)
	    end
	    xr_sound.set_sound_play(db.actor:id(), "pda_news")
	end
	
	if (smart.time_to_capture < 5) then
	    smart.time_to_capture = smart.time_to_capture + 1
        return	
    end	
	
    local levels = game_graph():vertex(smart.m_game_vertex_id):level_id()
	local linked = sim_tables.level_links[levels]	
	local currentLevelSmarts = sim_levels.level_information[levels].smarts
	local smartCollection = {}
	
	--'----------------------------------------------------------------------------------
	--' Настройка спавна отрядов при захвате точек
	--'----------------------------------------------------------------------------------
	
	local tp = sim_factions.faction_information[faction].total_power
	local bot = 0
	local r = 1
	
	local nubmer = ""
	local p = "_"
	local section = "novice"
	
	if tp <= 1000 then
		section = "novice"
		r = 1
	elseif tp <= 3500 then
		section = "advanced"
		r = 2
	elseif tp > 3500 then
		section = "veteran"
		r = 3
	end
	
	if section == "novice" then
		bot = tp / 140
		bot = math.floor(bot)
	elseif section == "advanced" then
		bot = tp / 500
		bot = math.floor(bot)
	elseif section == "veteran" then
		bot = tp / 1000
		bot = math.floor(bot)
		if bot > 8 then bot = 8 end
	end
	
	if linked  == "1" and section == "veteran" then 
		section = "advanced"
	elseif linked  == "2" and section == "veteran" then 
		section = "advanced" 
	end
	
	number = tostring(bot)
	
	if nubmer ~= "" then
		type = faction .."_sim_squad_".. section ..p..number, smart:name()
	else
		type = faction .."_sim_squad_".. section, smart:name()
	end
	   
	for i=1,#currentLevelSmarts	do
		smartCollection[#smartCollection+1] = currentLevelSmarts[i]
	end
	
	for lvl,_ in pairs(linked) do
		local smarts = sim_levels.level_information[lvl].smarts
		
		for i=1,#smarts do			    
		    smartCollection[#smartCollection+1] = smarts[i]
		end
	end
	
	local base = {{1000000000, 65534}}
	
	for i=1,#smartCollection do
	    local spawn_smart = alife_object(smartCollection[i])	
		if spawn_smart.props.base > 0 and spawn_smart.owning_faction == faction then
			local distance = spawn_smart.global_position:distance_to_sqr(smart.global_position)
			table.insert(base, {distance, spawn_smart.id})
		end
	end
	--store_table(base)
	table.remove(base, 1)
	--store_table(base)
	
	base = sim_brain.sort_priority_table(base)
	if not base or not base[1] then return end
	local spawn_smart_id = base[1][2]
	spawn_smart = alife_object(spawn_smart_id)
	
	if not spawn_smart then return end
	
	local smart_level = game_graph():vertex(spawn_smart.m_game_vertex_id):level_id()
	local actor_level = game_graph():vertex(alife():actor().m_game_vertex_id):level_id()
	
	if actor_level ~= smart_level and #base > 1 then
		for i = 1, #base do
			if actor_level == game_graph():vertex(alife_object(base[i][2]).m_game_vertex_id):level_id() then
				spawn_smart = alife_object(base[i][2])
				break
			end
		end
	end
	
	
	local spawn_smart_name = sim_script_to_text.smart_names[spawn_smart:name()] or spawn_smart:name()
	smart.waiting_for_squad = true			   
	local squad = sim_squad.create_squad(spawn_smart, nil, smart, type, nil, 2)
	smart.squad = squad

	if smart.last_last_owner == faction then
		if smart.props.base > 0 and capture_actor_news == true  then
			db.actor:give_game_news(("Capture goal"), ("Control over the base is returned in ".. script_to_text_smart ..", a detachment from your faction will soon arrive at this location"), sim_offline_to_online.getSenderIcon(sim_brain.actor_faction), 0, 15000)
		elseif smart.props.resource > 0 and capture_actor_news == true  then
			db.actor:give_game_news(("Capture goal"), ("Control over the resource point is returned in ".. script_to_text_smart ..", a detachment from your faction will soon arrive at this location"), sim_offline_to_online.getSenderIcon(sim_brain.actor_faction), 0, 15000)
		end
		xr_sound.set_sound_play(db.actor:id(), "pda_news")
		smart.time_to_capture = nil
	else
		if smart.props.base > 0 and capture_actor_news == true  then
			 db.actor:give_game_news(("Capture goal"), ("The base in ".. script_to_text_smart .." is captured, we'll send support from the nearest base ".. spawn_smart_name .. ", hold position until the arrival of the squad!"), sim_offline_to_online.getSenderIcon(sim_brain.actor_faction), 0, 15000)
		elseif smart.props.resource > 0 and capture_actor_news == true  then
			 db.actor:give_game_news(("Capture goal"), ("The resource point in ".. script_to_text_smart .." is captured, we'll send support from the nearest base ".. spawn_smart_name .. ", hold position until the arrival of the squad!"), sim_offline_to_online.getSenderIcon(sim_brain.actor_faction), 0, 15000)
		end
	   xr_sound.set_sound_play(db.actor:id(), "pda_news")
	   smart.time_to_capture = nil
	end 	

	if not (smart.waiting_for_squad) then
	   if smart.props.base > 0 and capture_actor_news == true  then
			db.actor:give_game_news(("Capture goal"), ("Capture of the base in ".. script_to_text_smart .." is not possible because all our bases are too far from it"), sim_offline_to_online.getSenderIcon(sim_brain.actor_faction), 0, 15000)
		elseif smart.props.resource > 0 and capture_actor_news == true  then
			db.actor:give_game_news(("Capture goal"), ("Capture of the resources point in ".. script_to_text_smart .." is not possible because all our bases are too far from it"), sim_offline_to_online.getSenderIcon(sim_brain.actor_faction), 0, 15000)
		end
		show_smart(smart)
	    xr_sound.set_sound_play(db.actor:id(), "pda_news")
	    smart.time_to_capture = nil	
	    smart.uncaptured = true
	end	
	
	show_smart(smart)
end

function smart_control(smart)

	local tg = time_global()

	if smart.last_npc_check ~= nil and tg < smart.last_npc_check then
		return
	end

	smart.last_npc_check = tg + 45000

	local squads = SIMBOARD.smarts[smart.id].squads

	for i,squad in pairs(squads) do
		local faction = squad:get_squad_community()
		
		if (squad.registered_in_simultaion and squad.current_action == 1 )then		
		    local npc_count = npc_count_passive(smart, faction)
					
		    if (faction ~= smart.owning_faction and not game_relations.is_factions_enemies(faction, smart.owning_faction)) then
		        if (smart.owning_faction ~= "none" and faction ~= "monster") then			  
				    if string.find(squad:name(), "veteran") or string.find(squad:name(), "advanced") or string.find(squad:name(), "novice") or string.find(squad:name(), "simulation") then
						sim_squad.remove_squad(squad)
					end
			    end
		    end
	    end
	end
end


function set_targets(smart)

	local tg = time_global()

	if smart.set_targets ~= nil and tg < smart.set_targets then return end

	smart.set_targets = tg + 1000
	
	local target_smart_count = 0
	for target,v in pairs(smart.target_smarts) do
		local other = alife_object(target)
		
		if (other and other.owning_faction) then
			if (other.owning_faction ~= "none" and not game_relations.is_factions_enemies(smart.owning_faction, other.owning_faction)) then
				smart.target_smarts[other.id] = nil
			else
				target_smart_count = target_smart_count + 1
			end
		end
	end

	if (target_smart_count < 3) then
		local targets = find_targets(smart, "table")
		if not targets or targets == 65535 then return end
		if (#targets > 0) then
			for i=1,#targets do
				if not (smart.target_smarts[targets[i][2]]) then
					smart.target_smarts[targets[i][2]] = true
					break
				end
			end
		end
	end

end

function spawn_defense_squad(smart)
	local time = level.get_time_days()*60*24+level.get_time_hours()*60+level.get_time_minutes()
	local faction = smart.owning_faction
	local npc_in_smart = npc_count_passive(smart, faction)
	
	local fi = sim_factions.faction_information[smart.owning_faction]
	
	local timer = spawn_defence_time
	
	if faction == sim_brain.actor_faction then
		if typ == "attack" then
			timer = timer * 4
		elseif typ == "default" then
			timer = timer
		elseif typ == "defend" then
			timer = timer / 2
		end
	elseif faction ~= sim_brain.actor_faction then
		if typ_ai == "attack" then
			timer = timer * 4
		elseif typ_ai == "default" then
			timer = timer
		elseif typ_ai == "defend" then
			timer = timer / 2
		end
	end
	
	if not smart.timerdef then smart.timerdef = time + timer end
	if time < smart.timerdef then return end
	
	if (fi) then
		if fi.faction_passive_npc_limit > fi.passive_npc then	
			local i = 0
			while npc_count_passive(smart, faction) < smart.max_population do
				sdbg("'while' spawning passive squads [%s]", i)
				sim_squad.create_squad(smart, faction, nil, nil, nil, 2)
				smart.timerdef = time + timer
				i = i + 1
				
				if i >= 20 then 
					sdbg("#SAFE: may be infinitive cycle. %s %s [%s]", npc_count_passive(smart, faction), smart.max_population, i)
					break 
				end
			end
		end
	end
end

function spawn_patrol_squad(smart)
	----printf("# SIM: Спавн патруля отключен")
	return 
end

function spawn_killers_squad(smart)
	----printf("# SIM: Спавн головорезов отключен")	
	return 
end

function spawn_attack_squad(smart, ignore)		
	local time = level.get_time_days()*60*24+level.get_time_hours()*60+level.get_time_minutes()
	
	local fi = sim_factions.faction_information[smart.owning_faction]
	
	local timer = spawn_attack_time
	
	local faction = smart.owning_faction
	
	if not ignore then
		if faction == sim_brain.actor_faction then
			if typ == "attack" then
				timer = timer / 2
			elseif typ == "default" then
				timer = timer
			elseif typ == "defend" then
				timer = timer * 4
			end
		elseif faction ~= sim_brain.actor_faction then
			if typ_ai == "attack" then
				timer = timer / 2
			elseif typ_ai == "default" then
				timer = timer
			elseif typ_ai == "defend" then
				timer = timer * 4
			end
		end	
	elseif ignore then
		timer = timer * 0.5
	end
	
	if not smart.timer then smart.timer = time + timer end
	if time < smart.timer then return end
	
	--printf("smart name %s", smart:name())
	if npc_count_attack(smart) >= smart.max_population then
		--printf("Smart %s cant spawn squad : %s/%s", smart:name(), npc_count_attack(smart), smart.max_population)
		return
	end

	local night = true
	
	local targets_id = 65535
	
	if ignore then
		local param = 1
		local level = sim_factions.faction_information[smart.owning_faction].level
		if level == 3 then 
			param = 1
		elseif level == 4 then
			if sim_factions.faction_information[smart.owning_faction].base_count < 3 then
				param = 1
			elseif sim_factions.faction_information[smart.owning_faction].resource_count < 6 then
				param = 2
			end
		end
		targets_id = find_targets(smart, "smart")
	elseif sim_brain.brain[faction].enemy then
		targets_id = find_targets_faction(smart, sim_brain.brain[faction].enemy)
	else
		targets_id = find_targets(smart, "smart")
	end
	
	if not targets_id or targets_id == 65535 then 
		return 
	end
   
	local success = false
		
	local target = alife_object(targets_id)
		
	if target then
		if ignore then 
			
			local lvl = alife():level_name(smart and game_graph():vertex(smart.m_game_vertex_id):level_id())
			if sim_factions.level_information[faction][lvl] then
				sim_squad.create_squad(smart, faction, target, nil, nil, 1)
				sim_brain.brain[faction].rush = 0
				success = true
			else
				success = false
			end
			
			--[[
			local power = npc_count_power(target, target.owning_faction)
			local cnt = 0
			local val = 0
			local sq = sim_squad.create_rush_squad(smart, faction, target, 1) 
			
			sim_squad.create_squad(smart, faction, target, nil, nil, 1)
			
			
			if sq then
				val = sim_offline_control.calculate_power(sq)
				power = power - val
				cnt = sim_squad.need_count(faction)
			end
			
			if power <= 0 or val == 0 then return end
			
			local f = math.ceil(power/val)
			
			if f ~= f then return end
			
			local p = math.random(f-1,f) 
			printf("f %s p %s ceil %s power %s val %s", f, p, power/val, power, val)
			if not p or p < 2 or p ~= p then return end
			for i = 1, p do
				sim_squad.create_rush_squad(smart, faction, target, 1) 
			end
			
			sim_brain.brain[faction].rush = 0
			]]--
		else
			sim_squad.create_squad(smart, faction, target, nil, nil, 1)
			success = true
		end
		
		local TimeFactor = level.get_time_factor()
		
		if success then 
			smart.timer = time + (timer*TimeFactor) -- таймер будет срабатывать каждые n минут
		end
	end
end

function on_game_start()
	RegisterScriptCallback("save_state",save_state)
	RegisterScriptCallback("load_state",load_state)
	CreateTimeEvent('smart', 'loading_list', 15, loading_list)
	CreateTimeEvent('smart', 'updating', 20, update)
end

all_smarts = {}

function loading_list()
	all_smarts = {}
	
	for i=1, 20000 do
	local smart = alife_object(i)
		if smart and smart:clsid() == clsid.smart_terrain then
			table.insert(all_smarts, smart.id)
		end
	end
	
	RemoveTimeEvent('smart', 'loading_list')
end

function update()

	if #all_smarts < 20 then
		loading_list()
		ResetTimeEvent('smart', 'updating', 30)
	end
	
	printf("$ start smart updating %s", time_global())
	
	for _, smart_id in pairs(all_smarts) do
	local smart = alife_object(smart_id)
		if smart and smart:clsid() == clsid.smart_terrain and smart.updating_squad and #smart.updating_squad > 0 then
			for i,squad_id in pairs(smart.updating_squad) do
				local squad = alife_object(squad_id)
				if squad and squad:clsid() == clsid.online_offline_group_s and squad.spawned_smart then
					local dist = alife_object(squad.spawned_smart).position:distance_to_sqr(squad.position)
					
					if dist >= 2500 then
						squad.spawned_smart = nil
						
						for i,squads in pairs(smart.updating_squad) do
							if (squads == squad.id) then
								sdbg("remove squad %s from smart %s", squad:name(), smart:name())
								table.remove(smart.updating_squad, i)
							end
						end
					end
				else
					table.remove(smart.updating_squad, i)
				end
			end
		end
	end
	
	printf("$ done smart updating %s", time_global())
	
	ResetTimeEvent('smart', 'updating', 30)
end

function save_state(m_data)
	if not m_data.smart_terrains then
		m_data.smart_terrains = {}
	end
		
	for i=1, 65534 do
		local obj = alife_object(i)
		if obj then
			if obj.props and (obj.props.territory or obj.props.base or obj.props.lair or obj.props.resource) then
				smart = obj
				sdbg("smart name %s id %s", smart:name(), smart.id)
				m_data.smart_terrains[smart.id] = {}
				if smart.updating_squad then
					for i,squad in pairs(smart.updating_squad) do
						table.insert(m_data.smart_terrains[smart.id], squad)
					end
				end
			end
		end
	end
end

function loading_smart(m_data)
	for it, smart_id in pairs(m_data.smart_terrains) do
		sdbg("%s true", it) -- тут ID смарта
		
		if #smart_id > 0 then
			for i,squad in pairs(smart_id) do
				sdbg("%s %s", i, squad)
				local smart = it and alife_object(it)
				if smart then
					if not smart.updating_squad then smart.updating_squad = {} end
					table.insert(smart.updating_squad, squad)
				end
			end
		end
		
		if smart then
			m_data.smart_terrains[it] = nil
		end
	end
	
	if #m_data.smart_terrains == 0 then
		m_data.smart_terrains = nil
		sdbg("Delete smart loading")
		RemoveTimeEvent('smart','load')
	else
		sdbg("Reset smart loading")
		ResetTimeEvent('smart', 'load', 3)
	end
end

function load_state(m_data)
	if not m_data.smart_terrains then
		return
	end
	
	sdbg("\nload\n")
	
	CreateTimeEvent('smart','load', 1, loading_smart, m_data)
end

function process_patrols(smart)

	local tg = time_global()

	if smart.process_patrols ~= nil and tg < smart.process_patrols then
		return
	end

	smart.process_patrols = tg + 2000
	
	local squads = SIMBOARD.smarts[smart.id].squads
	local level_info = sim_levels.level_information[smart.level_id]

	for id,squad in pairs(squads) do	

		if (squad.current_action == 1) then
			if not (squad.wait_time) then
				squad.wait_time = 5
			end
		end		
	
		if (squad.arrive_time and squad.wait_time) then		
			if (game.get_game_time():diffSec(squad.arrive_time) >= squad.wait_time) then		
	            if (squad.patrol and squad.current_action == 1) then
	                local faction = squad:get_squad_community()
					local random = math.random(2) 
		            for i,sm in pairs(level_info.smarts) do
			            local other = sm and alife_object(sm)	
				        if (other and other.props) then
					        if random == 1 then
						        if (other.props.territory > 0) then
							        sim_squad.set_target(squad, sm)									
							        break
						        end						
					        else
						        if (other.props.resource > 0) then
							        sim_squad.set_target(squad, sm)									
							        break
								end
							end
						end
					end	
                end											
	        end
        end
    end
end 

function spawn_mutants(smart)

	local time = level.get_time_days()*60*24+level.get_time_hours()*60+level.get_time_minutes()
	if not smart.timer then smart.timer = time + spawn_mutant_time end
	if time < smart.timer then return end

	local mutants_on_level = sim_offline_control.get_num_squads_on_level(smart.level_id, "monster")
	local mutants = squad_count(smart, "monster")
	local mutant_coef = sim_brain.check_mutant_coef(smart)
	local level = alife():level_name(game_graph():vertex(smart.m_game_vertex_id):level_id())
	local section	
	
	if level ~= l12u_control_monolith or level ~= l12u_sarcofag or level ~= l11_hospital then
	    if (mutants_on_level < mutant_coef) then
		    if mutants <= smart.max_population then	
		
				local ini = ini_file("settings\\mutants_tier_by_lvl.ltx")
                local tier = ini:r_string_ex("respawn",level)
				local table = alun_utils.parse_list(ini, "respawn",level)
				
	            if not table then return end
		          
				section = table[math.random(#table)]		
			
			    if section then
                   sim_squad.create_squad(smart, nil, nil, section, nil, 1)
			    end
				
				smart.timer = time + spawn_mutant_time
		    end
	    end
	end
end

function process_mutants(smart)

	local tg = time_global()

	if smart.process_mutants ~= nil and tg < smart.process_mutants then
		return
	end

	smart.process_mutants = tg + 10000
	
	local squads = SIMBOARD.smarts[smart.id].squads
	local night = (level.get_time_hours() < 6 or level.get_time_hours() > 20)
	local level_info = sim_levels.level_information[smart.level_id]

	for id,squad in pairs(squads) do
	    if squad:get_squad_community() == "monster" then
		    for i,sm in pairs(level_info.smarts) do
		        if (game.get_game_time():diffSec(squad.arrive_time) >= squad.wait_time) then	
			        local other = sm and alife_object(sm)	
					if (other and other.props) then
	                    if (night) then
						    if math.random(100) > 25 then
			                    if (other.owning_faction ~= "none") then
				                   sim_squad.set_target(squad, sm)
				                   break	
                                end		
                            else
							    if (other.owning_faction == "none") then
							 	    local mutants_in_target = squad_count(other, "monster")
								
                                    if mutants_in_target < 2 then
								       sim_squad.set_target(squad, sm)									
								       break
							        end
							    end	
                            end								
			            else											
							if (other.owning_faction == "none") then
								local mutants_in_target = squad_count(other, "monster")
								
                                if mutants_in_target < 2 then
								    sim_squad.set_target(squad, sm)									
								    break
							    end
							end
				        end
				    end				
	            end
            end
	    end
    end
end

function find_targets_all(smart, str)
	local level = game_graph():vertex(smart.m_game_vertex_id):level_id()
	
	local levelID
	local link = sim_tables.ll
	local faction = smart.owning_faction
	local h = #link[level]
	local q = math.random(1, h)
	levelID = link[level][q]
	
	local linked = sim_tables.level_links[level]	
	if not sim_levels.level_information[level] then return 65535 end
	local currentLevelSmarts = sim_levels.level_information[level].smarts
	
	local linked2 = sim_tables.level_links[levelID]
	local currentLevelSmarts2 = sim_levels.level_information[levelID].smarts
	
	local smartCollection = {}
	local faction = smart.owning_faction or "none"

	for i = 1,#currentLevelSmarts	do
		table.insert(smartCollection, currentLevelSmarts[i])
	end
	
	for i = 1, #currentLevelSmarts2 do
		table.insert(smartCollection, currentLevelSmarts2[i])
	end
	
	for lvl,_ in pairs(linked) do
		local smarts = sim_levels.level_information[lvl].smarts
		
		for i = 1, #smarts do
			table.insert(smartCollection, smarts[i])
		end
	end
	
	local targets = {}
	
	if faction == "monster" or faction == "trader" or faction == "zombied" then
		return 65535
	end
	
	for i = 1, #smartCollection do

		local other = alife_object(smartCollection[i])		
		
		if (other and other.props and other.global_position) then
			if other.props.base > 0
			or other.props.resource > 0
			or other.props.territory > 0
			then
				local dist = smart.global_position:distance_to_sqr(other.global_position)
				local priority = 0
				local faction2 = other.owning_faction or "none"			
				local otherLevel = game_graph():vertex(other.m_game_vertex_id):level_id()
				if (other.props[faction]) then
					priority = priority + other.props[faction]
				end
				
				if (other.props.base > 0) then
					priority = priority + 120
					
                    if other.owning_faction == "none" then
				       priority = priority - 20
					end
				end
				
				if (other.props.resource > 0) then
					priority = priority + 80
					
					if other.owning_faction == "none" then
				       priority = priority - 10
					end
				end			
				
				if (other.target_smarts) then
					if (other.target_smarts[smart.id]) then
						priority = priority + 40
					end
				end
				
				if (other.props.territory > 0) then
					priority = priority + 40
				end
							
				if (otherLevel == level) then
					priority = priority + 120
				end
										               
				if db.actor and not(db.actor:has_info("bar_deactivate_radar_done")) then
                   if sim_brain.monolith_level(other) and (faction ~= "monolith" and faction ~= "zombied" and faction ~= "monster") then
                      priority = 0
                   end	
                end				  
				
				if (faction2 == faction) then
					if sim_factions.faction_information[faction2] and sim_factions.faction_information[faction] and sim_factions.faction_information[faction2].base_count > sim_factions.faction_information[faction2].base_count then
						priority = priority + 100
					end
				end	
	
				if (faction2 == "none" or game_relations.is_factions_enemies(faction, faction2)) 
				and ((typ == "attack" and faction == sim_brain.actor_faction) or (typ_ai == "attack" 
				and faction ~= sim_brain.actor_faction)) then
					priority = priority + 400
					--printf("enemy attack")
				end
				
				if (faction2 == faction or game_relations.is_factions_friends(faction, faction2) or 
				(not game_relations.is_factions_friends(faction, faction2) and not game_relations.is_factions_enemies(faction, faction2))) 
				and ((typ == "defend" and faction == sim_brain.actor_faction) or (typ_ai == "defend" 
				and faction ~= sim_brain.actor_faction)) then
					priority = priority + 400
					--printf("neutral/friend defend")
				end
				
				targets[#targets+1] = {math.abs(dist / priority), other.id}
			end
		end
	end
	
	if #targets == 0 then
		for i = 1, #smartCollection do
			local other = alife_object(smartCollection[i])		
			if (other and other.props) then
				if other.props.lair > 0
				then
					local dist = smart.global_position:distance_to_sqr(other.global_position)
					local priority = 0
					local faction2 = other.owning_faction or "none"			
					local otherLevel = game_graph():vertex(other.m_game_vertex_id):level_id()
					if (other.props[faction]) then
						priority = priority + other.props[faction]
					end
					
					if (other.target_smarts) then
						if (other.target_smarts[smart.id]) then
							priority = priority + 40
						end
					end
								
					if (otherLevel == level) then
						priority = priority + 120
					end		  
					
					if sim_factions.faction_information[faction2] and sim_factions.faction_information[faction] and sim_factions.faction_information[faction2].base_count > sim_factions.faction_information[faction2].base_count then
						priority = priority + 100
					end
					
					if (faction2 == "none" or game_relations.is_factions_enemies(faction, faction2)) 
					and ((typ == "attack" and faction == sim_brain.actor_faction) or (typ_ai == "attack" 
					and faction ~= sim_brain.actor_faction)) then
						priority = priority + 400
						--printf("enemy attack")
					end
					
					if (faction2 == faction or game_relations.is_factions_friends(faction, faction2) or 
					(not game_relations.is_factions_friends(faction, faction2) and not game_relations.is_factions_enemies(faction, faction2))) 
					and ((typ == "defend" and faction == sim_brain.actor_faction) or (typ_ai == "defend" 
					and faction ~= sim_brain.actor_faction)) then
						priority = priority + 400
						--printf("neutral/friend defend")
					end
					
					targets[#targets+1] = {math.abs(dist / priority), other.id}
					
				end
			end
		end
	end
	
	
	targets = sim_brain.sort_priority_table(targets)

	if #targets == 0 then
		return 65535
	end
	
	if str == "table" then
		return targets
	elseif str == "smart" then
		local a = #targets
		if a > 10 then a = 10 end
		local b = math.random(1, a)
		if a == 1 then 
			return targets[1][2]
		else
			return targets[b][2]
		end	
	end
end

function find_targets_faction(smart, faction_enemy)
	local level = game_graph():vertex(smart.m_game_vertex_id):level_id()
	
	local levelID
	local link = sim_tables.ll
	local faction = smart.owning_faction
	local h = #link[level]
	local q = math.random(1, h)
	levelID = link[level][q]
	
	local linked = sim_tables.level_links[level]	
	if not sim_levels.level_information[level] then return 65535 end
	local currentLevelSmarts = sim_levels.level_information[level].smarts
	
	local linked2 = sim_tables.level_links[levelID]
	local currentLevelSmarts2 = sim_levels.level_information[levelID].smarts
	
	local smartCollection = {}
	local faction = smart.owning_faction or "none"

	for i = 1,#currentLevelSmarts	do
		table.insert(smartCollection, currentLevelSmarts[i])
	end
	
	for i = 1, #currentLevelSmarts2 do
		table.insert(smartCollection, currentLevelSmarts2[i])
	end
	
	for lvl,_ in pairs(linked) do
		local smarts = sim_levels.level_information[lvl].smarts
		
		for i = 1, #smarts do
			table.insert(smartCollection, smarts[i])
		end
	end
	
	local targets = {}
	
	if faction == "monster" or faction == "trader" or faction == "zombied" then
		return 65535
	end
	
	for i = 1, #smartCollection do

		local other = alife_object(smartCollection[i])		
		
		if (other and other.props) then
			if other.props.base > 0
			or other.props.resource > 0
			or other.props.territory > 0
			then
				local dist = smart.global_position:distance_to_sqr(other.global_position)
				local priority = 0
				local faction2 = other.owning_faction or "none"			
				local otherLevel = game_graph():vertex(other.m_game_vertex_id):level_id()
				if (other.props[faction]) then
					priority = priority + other.props[faction]
				end
				
				if (other.props.base > 0) then
					if sim_brain.can_base() then
						if faction2 == faction_enemy then 
							priority = priority + 200
						else
							priority = 0
						end
					elseif not sim_brain.can_base() and sim_brain.can_res() then
						priority = 0
					else
						priority = priority + 120
					end
				end
				
				if (other.props.resource > 0) then
					if sim_brain.can_res() then
						if faction2 == faction_enemy then
							priority = priority + 200
						else
							priority = 0
						end
					elseif not sim_brain.can_res() then
						priority = priority + 120
					end
				end
				
				if (other.target_smarts) then
					if (other.target_smarts[smart.id]) then
						priority = priority + 40
					end
				end
				
				if (other.props.territory > 0) then
					priority = priority + 40
				end
							
				if (otherLevel == level) then
					priority = priority + 200
				end
										               
				if db.actor and not(db.actor:has_info("bar_deactivate_radar_done")) then
                   if sim_brain.monolith_level(other) and (faction ~= "monolith" and faction ~= "zombied" and faction ~= "monster") then
                      priority = 0
                   end	
                end		
				
				if (faction2 == "none" or game_relations.is_factions_enemies(faction, faction2)) 
				and ((typ == "attack" and faction == sim_brain.actor_faction) or (typ_ai == "attack" 
				and faction ~= sim_brain.actor_faction)) then
					priority = priority + 200
					--printf("enemy attack")
				end
				
				if (faction2 == faction or game_relations.is_factions_friends(faction, faction2) or 
				(not game_relations.is_factions_friends(faction, faction2) and not game_relations.is_factions_enemies(faction, faction2))) 
				and ((typ == "defend" and faction == sim_brain.actor_faction) or (typ_ai == "defend" 
				and faction ~= sim_brain.actor_faction)) then
					priority = priority + 50
					--printf("neutral/friend defend")
				end
				
				if (other.props.base > 0) then
					if (not sim_brain.can_base() and sim_brain.can_res()) or faction2 ~= faction_enemy then
						priority = 0
					end
				end
				
				targets[#targets+1] = {math.abs(dist / priority), other.id}
			end
		end
	end
	
	if #targets == 0 then
		for i = 1, #smartCollection do
			local other = alife_object(smartCollection[i])		
			if (other and other.props) then
				if other.props.lair > 0
				then
					local dist = smart.global_position:distance_to_sqr(other.global_position)
					local priority = 0
					local faction2 = other.owning_faction or "none"			
					local otherLevel = game_graph():vertex(other.m_game_vertex_id):level_id()
					if (other.props[faction]) then
						priority = priority + other.props[faction]
					end
					
					if (other.target_smarts) then
						if (other.target_smarts[smart.id]) then
							priority = priority + 40
						end
					end
								
					if (otherLevel == level) then
						priority = priority + 120
					end		  
					
					if (faction2 == "none" or game_relations.is_factions_enemies(faction, faction2)) then
						if sim_factions.faction_information[faction2] and sim_factions.faction_information[faction] and sim_factions.faction_information[faction2].base_count > sim_factions.faction_information[faction2].base_count then
							priority = priority + 100
						end
					end
					
					if (faction2 == "none" or game_relations.is_factions_enemies(faction, faction2)) 
					and ((typ == "attack" and faction == sim_brain.actor_faction) or (typ_ai == "attack" 
					and faction ~= sim_brain.actor_faction)) then
						priority = priority + 400
						--printf("enemy attack")
					end
					
					if (faction2 == faction or game_relations.is_factions_friends(faction, faction2) or 
					(not game_relations.is_factions_friends(faction, faction2) and not game_relations.is_factions_enemies(faction, faction2))) 
					and ((typ == "defend" and faction == sim_brain.actor_faction) or (typ_ai == "defend" 
					and faction ~= sim_brain.actor_faction)) then
						priority = priority + 400
						--printf("neutral/friend defend")
					end
					
					targets[#targets+1] = {math.abs(dist / priority), other.id}
				end
			end
		end
	end
	
	if #targets == 0 then
		return 65535
	end
	
	targets = sim_brain.sort_priority_table(targets)
	
	if str == "table" then
		return targets
	elseif str == "smart" then
		local a = #targets
		if a > 10 then a = 10 end
		local b = math.random(1, a)
		return targets[b][2]
	end
end

function find_targets(smart, str)

	local level = game_graph():vertex(smart.m_game_vertex_id):level_id()
	
	local levelID
	local link = sim_tables.ll
	local faction = smart.owning_faction
	local h = #link[level]
	local q = math.random(1, h)
	levelID = link[level][q]
	
	local linked = sim_tables.level_links[level]	
	if not sim_levels.level_information[level] then return 65535 end
	local currentLevelSmarts = sim_levels.level_information[level].smarts
	
	local linked2 = sim_tables.level_links[levelID]
	local currentLevelSmarts2 = sim_levels.level_information[levelID].smarts
	
	local smartCollection = {}
	local faction = smart.owning_faction or "none"

	for i = 1,#currentLevelSmarts	do
		table.insert(smartCollection, currentLevelSmarts[i])
	end
	
	----printf("\n\nStage I \n%s", faction)
	--store_table(smartCollection)
	
	for i = 1, #currentLevelSmarts2 do
		table.insert(smartCollection, currentLevelSmarts2[i])
	end
	
	----printf("\nStage II")
	--store_table(smartCollection)
	
	for lvl,_ in pairs(linked) do
		local smarts = sim_levels.level_information[lvl].smarts
		
		for i = 1, #smarts do
			table.insert(smartCollection, smarts[i])
			--smartCollection[#smartCollection+1] = smarts[i]
		end
	end
	
	----printf("\nStage III")
	--store_table(smartCollection)
	
	local targets = {}
	
	if faction == "monster" or faction == "trader" or faction == "zombied" then
		return 65535
	end
	
	for i = 1, #smartCollection do

		local other = alife_object(smartCollection[i])		
		
		if (other and other.props) then
			if other.props.base > 0
			or other.props.resource > 0
			or other.props.territory > 0
			then
				local dist = smart.global_position:distance_to_sqr(other.global_position)
				local priority = 0
				local faction2 = other.owning_faction or "none"			
				local otherLevel = game_graph():vertex(other.m_game_vertex_id):level_id()
				if (other.props[faction]) then
					priority = priority + other.props[faction]
				end
				
				if (other.props.base > 0) then
					if sim_brain.can_base() then
						if faction2 ~= faction and (game_relations.is_factions_enemies(faction, faction2) or faction2 == "none") then 
							priority = priority + 200
							
							if other.owning_faction == "none" then
							   priority = priority - 50
							end
						else
							priority = 0
						end
					elseif not sim_brain.can_base() and sim_brain.can_res() then
						priority = 0
					else
						priority = priority + 120
						
						if other.owning_faction == "none" then
						   priority = priority - 20
						end
					end
				end
				
				if (other.props.resource > 0) then
					if sim_brain.can_res() then
						if faction2 ~= faction and (game_relations.is_factions_enemies(faction, faction2) or faction2 == "none") then
							priority = priority + 200
							
							if other.owning_faction == "none" then
							   priority = priority - 50
							end
						else
							priority = 0
						end
					elseif not sim_brain.can_res() then
						priority = priority + 120
						
						if other.owning_faction == "none" then
						   priority = priority - 20
						end
					end
				end
				
				if (other.target_smarts) then
					if (other.target_smarts[smart.id]) then
						priority = priority + 40
					end
				end
				
				if (other.props.territory > 0) then
					priority = priority + 40
				end
							
				if (otherLevel == level) then
					priority = priority + 200
				end
										               
				if db.actor and not(db.actor:has_info("bar_deactivate_radar_done")) then
                   if sim_brain.monolith_level(other) and (faction ~= "monolith" and faction ~= "zombied" and faction ~= "monster") then
                      priority = 0
                   end	
                end				  
				
				if (faction2 == "none" or game_relations.is_factions_enemies(faction, faction2)) 
				and ((typ == "attack" and faction == sim_brain.actor_faction) or (typ_ai == "attack" 
				and faction ~= sim_brain.actor_faction)) then
					priority = priority + 200
					--printf("enemy attack")
				end
				
				if (faction2 == faction or game_relations.is_factions_friends(faction, faction2) or 
				(not game_relations.is_factions_friends(faction, faction2) and not game_relations.is_factions_enemies(faction, faction2))) 
				and ((typ == "defend" and faction == sim_brain.actor_faction) or (typ_ai == "defend" 
				and faction ~= sim_brain.actor_faction)) then
					priority = priority + 50
					--printf("neutral/friend defend")
				end
				
				if (other.props.base > 0) then
					if not sim_brain.can_base() and sim_brain.can_res() then
						priority = 0
					end
				end
				
				if (faction2 == "none" or game_relations.is_factions_enemies(faction, faction2)) then
					if sim_factions.faction_information[faction2] and sim_factions.faction_information[faction] and sim_factions.faction_information[faction2].base_count > sim_factions.faction_information[faction2].base_count then
						priority = priority + 100
					end
					
					targets[#targets+1] = {math.abs(dist / priority), other.id}
				end
			end
		end
	end
	
	if #targets == 0 then
		for i = 1, #smartCollection do
			local other = alife_object(smartCollection[i])		
			if (other and other.props) then
				if other.props.lair > 0
				then
					local dist = smart.global_position:distance_to_sqr(other.global_position)
					local priority = 0
					local faction2 = other.owning_faction or "none"			
					local otherLevel = game_graph():vertex(other.m_game_vertex_id):level_id()
					if (other.props[faction]) then
						priority = priority + other.props[faction]
					end
					
					if (other.target_smarts) then
						if (other.target_smarts[smart.id]) then
							priority = priority + 40
						end
					end
								
					if (otherLevel == level) then
						priority = priority + 120
					end		  
					
					if (faction2 == "none" or game_relations.is_factions_enemies(faction, faction2)) 
					and ((typ == "attack" and faction == sim_brain.actor_faction) or (typ_ai == "attack" 
					and faction ~= sim_brain.actor_faction)) then
						priority = priority + 400
						--printf("enemy attack")
					end
					
					if (faction2 == faction or game_relations.is_factions_friends(faction, faction2) or 
					(not game_relations.is_factions_friends(faction, faction2) and not game_relations.is_factions_enemies(faction, faction2))) 
					and ((typ == "defend" and faction == sim_brain.actor_faction) or (typ_ai == "defend" 
					and faction ~= sim_brain.actor_faction)) then
						priority = priority + 400
						--printf("neutral/friend defend")
					end
					
					if (faction2 == "none" or game_relations.is_factions_enemies(faction, faction2)) then
						if sim_factions.faction_information[faction2] and sim_factions.faction_information[faction] and sim_factions.faction_information[faction2].base_count > sim_factions.faction_information[faction2].base_count then
							priority = priority + 100
						end
						
						targets[#targets+1] = {math.abs(dist / priority), other.id}
					end
				end
			end
		end
	end
	
	if #targets == 0 then
		----printf("no targets")
		return 65535
	end
	
	targets = sim_brain.sort_priority_table(targets)
	----printf("\n\n targets:")
	--store_table(targets)
	
	if str == "table" then
		return targets
	elseif str == "smart" then
		local a = #targets
		if a > 10 then a = 10 end
		local b = math.random(1, a)
		return targets[b][2]
	end
end



function smart_terrain.se_smart_terrain.show(self)
end

function smart_terrain.se_smart_terrain.hide(self)
end

function get_simulation_info(smart)

	local sim_name = sim_script_to_text.smart_names[smart:name()]
	local power = npc_count_power(smart, smart.owning_faction)
	
	local props = ""
	local type = ""


	if (sim_name) then
		props = endl .. sim_name .. endl
	else
	    props = endl .. smart:name() .. endl
	end


	if (smart.props) then
		if (smart.props.base > 0) then
			type = game.translate_string("sim_base")
		elseif (smart.props.resource > 0) then
			type = game.translate_string("sim_resource")
		elseif (smart.props.territory > 0) then
			type = game.translate_string("sim_territory")
		elseif (smart.props.lair > 0) then
			type = game.translate_string("sim_lair")
		end
	end	
	
	if smart.owning_faction == "none" then
	   props = props .. endl ..  type.. endl
	elseif smart.owning_faction == "zombied" then	
	   props = props .. endl.. type .. ", " .. game.translate_string("sim_zombied_smart") .. endl
	else
	   props = props .. endl .. type .. ", " .. game.translate_string("sim_control_smart") .. tb .. game.translate_string(smart.owning_faction) .. endl
	   
        if power == 0 then
	        props = props .. endl .. game.translate_string("sim_smart_power_1") .. endl
	    elseif power > 0 and power <= 50 then
			props = props .. endl .. game.translate_string("sim_smart_power_2") .. endl
		elseif power > 50 and power <= 100 then
			props = props .. endl .. game.translate_string("sim_smart_power_3") .. endl
	    elseif power > 100 and power <= 200 then
	        props = props .. endl .. game.translate_string("sim_smart_power_4") .. endl
	    elseif power > 200 and power <= 300 then
            props = props .. endl .. game.translate_string("sim_smart_power_5") .. endl
		elseif power > 400 then
            props = props .. endl .. game.translate_string("sim_smart_power_6") .. endl
        end
	end
	
	return props
end

function friend_info(smart)

	local sim_name = sim_script_to_text.smart_names[smart:name()]
	local power = npc_count_power(smart, smart.owning_faction)
	--local npc = npc_count(smart, smart.owning_faction)
	local npc = npc_count(smart, smart.owning_faction)
	local props = ""
	local type = ""

	if (smart.props) then
		if (smart.props.base > 0) then
			type = game.translate_string("sim_base")
		elseif (smart.props.resource > 0) then
			type = game.translate_string("sim_resource")
		elseif (smart.props.territory > 0) then
			type = game.translate_string("sim_territory")
		elseif (smart.props.lair > 0) then
			type = game.translate_string("sim_lair")
		end
	end	
	
	if (sim_name) then
		props = type .. tb .. sim_name .. endl
	else
	    props = type .. tb .. smart:name() .. endl
	end
	
	props = props .. endl .. game.translate_string("sim_smart_power") .. tb .. power .. endl
	
	props = props .. endl .. game.translate_string("sim_smart_npc") .. tb .. npc .. tb .. endl
	
	props = props .. endl .. game.translate_string("sim_smart_owner") .. tb ..game.translate_string(smart.owning_faction) .. endl
	
	return props
end

function neutral_info(smart)

	local sim_name = sim_script_to_text.smart_names[smart:name()]
	local power = npc_count_power(smart, smart.owning_faction)
	local npc = npc_count(smart, smart.owning_faction)
	
	local props = ""
	local type = ""

	if (smart.props) then
		if (smart.props.base > 0) then
			type = game.translate_string("sim_base")
		elseif (smart.props.resource > 0) then
			type = game.translate_string("sim_resource")
		elseif (smart.props.territory > 0) then
			type = game.translate_string("sim_territory")
		elseif (smart.props.lair > 0) then
			type = game.translate_string("sim_lair")
		end
	end	
	
	if (sim_name) then
		props = type .. tb .. sim_name .. endl
	else
	    props = type .. tb .. smart:name() .. endl
	end
	
	props = props .. endl .. game.translate_string("sim_smart_npc") .. tb .. npc .. tb .. endl
	
	props = props .. endl .. game.translate_string("sim_smart_owner") .. tb ..game.translate_string(smart.owning_faction) .. endl
	
	return props
end

function enemy_info(smart)

	local sim_name = sim_script_to_text.smart_names[smart:name()]
	local power = npc_count_power(smart, smart.owning_faction)
	local npc = npc_count(smart, smart.owning_faction)
	
	local props = ""
	local type = ""

	if (smart.props) then
		if (smart.props.base > 0) then
			type = game.translate_string("sim_base")
		elseif (smart.props.resource > 0) then
			type = game.translate_string("sim_resource")
		elseif (smart.props.territory > 0) then
			type = game.translate_string("sim_territory")
		elseif (smart.props.lair > 0) then
			type = game.translate_string("sim_lair")
		end
	end	
	
	if (sim_name) then
		props = type .. tb .. sim_name .. endl
	else
	    props = type .. tb .. smart:name() .. endl
	end
	
	return props
end

function none_info(smart)

	local sim_name = sim_script_to_text.smart_names[smart:name()]
	local power = npc_count_power(smart, smart.owning_faction)
	local npc = npc_count(smart, smart.owning_faction)
	
	local props = ""
	local type = ""

	if (smart.props) then
		if (smart.props.base > 0) then
			type = game.translate_string("sim_base")
		elseif (smart.props.resource > 0) then
			type = game.translate_string("sim_resource")
		elseif (smart.props.territory > 0) then
			type = game.translate_string("sim_territory")
		elseif (smart.props.lair > 0) then
			type = game.translate_string("sim_lair")
		end
	end	
	
	if (sim_name) then
		props = type .. tb .. sim_name .. endl
	else
	    props = type .. tb .. smart:name() .. endl
	end
	
	props = props .. game.translate_string("sim_smart_max_count") .. tb .. smart.max_population .. tb .. game.translate_string("sim_smart_npc_3") .. endl
	
	props = props .. endl .. endl .. game.translate_string("sim_smart_capture") .. endl
		
	return props
end

function squad_count(smart, faction)

	if not (smart.owning_faction) then
		smart.owning_faction = "none"
	end
	
	local squads = SIMBOARD.smarts[smart.id].squads
    local squad_count = 0
	
	for i,squad in pairs(squads) do
		if (squad.registered_in_simultaion and squad:get_squad_community() == faction) then
			squad_count = squad_count + 1					
		end
	end

	return squad_count
end

function npc_count(smart, faction)

	if not (smart.owning_faction) then
		smart.owning_faction = "none"
	end
	
	local squads = SIMBOARD.smarts[smart.id].squads
    local npc_count = 0
	
	for i,squad in pairs(squads) do
		if not squad.registered_in_simultaion then
			local factions = squad:get_squad_community()
			
			if (sim_tables.registered_squads[factions]) then
				sim_tables.registered_squads[factions][squad.id] = smart.id
				squad.assigned_target_id = smart.id
				squad.registered_in_simultaion = true
				smart:on_reach_target(squad)
			end
		end
		
		if (squad.registered_in_simultaion and squad:get_squad_community() == faction) then
		    local npc_in_squad = squad:npc_count()
			npc_count = npc_count + npc_in_squad					
		end
	end

	return npc_count
end

function npc_count_power(smart, faction)

	if not (smart.owning_faction) then
		smart.owning_faction = "none"
	end
	
	local squads = SIMBOARD.smarts[smart.id].squads
    local power_count = 0
	
	for i,squad in pairs(squads) do
		if not squad.registered_in_simultaion then
			local factions = squad:get_squad_community()
			
			if (sim_tables.registered_squads[factions]) then
				sim_tables.registered_squads[factions][squad.id] = smart.id
				squad.assigned_target_id = smart.id
				squad.registered_in_simultaion = true
				smart:on_reach_target(squad)
			end
		end
		
		if (squad.registered_in_simultaion and squad:get_squad_community() == faction) then
			if squad ~= nil then
				local power = sim_offline_control.ocs_power_table[squad.id]
				if power ~= nil then
					power_count = power_count + power
				end
			end						
		end
	end

    if power_count ~= nil then
	    return power_count
	else 
	    return 0
	end
end

function npc_check(squad)
	if squad:clsid() ~= clsid.online_offline_group_s then
		-- САУ: Удаляем всякую хуйню, которая не относится к сквадам.
		return 0
	end
	
	local members = squad:npc_count()
	--tonumber(stpk_utils.get_squad_data(squad).members_count)	
	-- Как только сюда попадает не squad, а что-то другое, сразу получаем утечку памяти :(
	return members
end

function npc_count_attack(smart)
	local npc_count = 0
	
	if not smart.updating_squad or #smart.updating_squad == 0 then return 0 end
	
	for i,squad in pairs(smart.updating_squad) do
		local sqd = alife_object(squad)
		
		if sqd then
			if sqd:clsid() ~= clsid.online_offline_group_s then
				-- САУ: Удаляем всякую хуйню, которая не относится к сквадам.
				table.remove(smart.updating_squad, squad)
			end
			
			local npc_in_squad = npc_check(sqd)
			if npc_in_squad <= 0 then
				-- САУ: Удаляем всякую хуйню, которая не относится к сквадам.
				table.remove(smart.updating_squad, squad)
			end
			
			npc_count = npc_count + npc_in_squad
		end
	end
    
    if npc_count ~= nil then 
	    return npc_count
	else
	     return 0
	end
end

function npc_count_passive(smart, faction)

	if not (smart.owning_faction) then
		smart.owning_faction = "none"
	end
	
	local squads = SIMBOARD.smarts[smart.id].squads
    local npc_count = 0
	
	for i,squad in pairs(squads) do
		if not squad.registered_in_simultaion then
			local factions = squad:get_squad_community()
			
			if (sim_tables.registered_squads[factions]) then
				sim_tables.registered_squads[factions][squad.id] = smart.id
				squad.assigned_target_id = smart.id
				squad.registered_in_simultaion = true
				smart:on_reach_target(squad)
			end
		end
		
		if (squad.registered_in_simultaion and squad:get_squad_community() == faction and squad.current_action == 1) then
		    local npc_in_squad = squad:npc_count()
			npc_count = npc_count + npc_in_squad					
		end
	end
    
    if npc_count ~= nil then 
	    return npc_count
	else
	     return 0
	end
end

function npc_count_active(smart, faction)

	if not (smart.owning_faction) then
		smart.owning_faction = "none"
	end
	
	local squads = SIMBOARD.smarts[smart.id].squads
    local npc_count = 0
	
	for i,squad in pairs(squads) do
		if (squad.registered_in_simultaion and squad:get_squad_community() == faction and squad.current_action == 0) then
		    local npc_in_squad = squad:npc_count()
			npc_count = npc_count + npc_in_squad					
		end
	end

	if npc_count ~= nil then 
	    return npc_count
	else
	     return 0
	end
end

function check_owner(smart)

	if not (smart) then
		return
	end
	
	if (smart.time_to_capture) then
	    smart.owning_faction = "none"
	    return
	end
	
	if (not SIMBOARD.smarts[smart.id]) then
		smart.owning_faction = "none"
		return
	end
	
	if not (SIMBOARD.smarts[smart.id].squads) then
		smart.owning_faction = "none"
		return
	end

	local squads = SIMBOARD.smarts[smart.id].squads
	local squadCount = {}
	local squadPowers = {}
	
	if not (smart.owning_faction) then
		smart.owning_faction = "none"
	end
	
	local text = lostpath_main.config:r_string_ex("scripts","smart_target")
	if not text then text = "none" end
	
	for i,squad in pairs(squads) do
		if not squad.registered_in_simultaion then
			local factions = squad:get_squad_community()
			
			if (sim_tables.registered_squads[factions]) then
				sim_tables.registered_squads[factions][squad.id] = smart.id
				squad.assigned_target_id = smart.id
				squad.registered_in_simultaion = true
				smart:on_reach_target(squad)
			end
		end
		
		local dist = smart.position:distance_to_sqr(squad.position)
		-- проблема в том,что онлайновые нпс все-равно хуй кладут на эти точки, если у них есть какой-то вейпоинт
		--[[
		if text ~= "teleport" and text ~= "reset_smart" then
			if dist >= 2500 and dist <= 10000 then
				if squad.assigned_target_id then
					local targetss = squad.assigned_target_id
					sim_squad.set_target(squad, smart_terrain_by_id)
					sim_squad.set_target(squad, targetss)
				end
			end
		end
		]]--
		if text == "teleport" then
			if dist >= 2500 and dist <= 10000 and game_graph():vertex(squad.m_game_vertex_id):level_id() == game_graph():vertex(smart.m_game_vertex_id):level_id() then 
				local faction = squad:get_squad_community()
				local squad_target = squad.assigned_target_id and simulation_objects.get_sim_obj_registry().objects[squad.assigned_target_id]
				if squad_target and faction == smart.owning_faction then
					TeleportSquad(squad,squad_target.position,squad_target.m_level_vertex_id,squad_target.m_game_vertex_id)
				end
			end
		end
		
		if (text == "reset_smart" and dist <= 10000) or text ~= "reset_smart" then
			if ((squad.current_action == 1 or squad.combat_action == 1) and squad.registered_in_simultaion) then
				
				local faction = squad:get_squad_community()
				
				if not (squadCount[faction]) then
					squadCount[faction] = 0
					squadPowers[faction] = 0
				end
				
				local power = sim_offline_control.ocs_power_table[squad.id]
				
				if (power and power > 0) then
					squadPowers[faction] = squadPowers[faction] + power
				end
				
				if squad.rush_faction then
					squad.rush_faction = nil
					sim_factions.faction_information[faction].rush_squads = sim_factions.faction_information[faction].rush_squads - 1
				end

				squadCount[faction] = squadCount[faction] + 1
			end
		end
	end
	
	local owner = "none"
	for faction,count in pairs(squadCount) do	
		if (owner == "none" or faction == smart.owning_faction) then		
			owner = faction
		elseif (squadCount[owner] < count and smart.owning_faction == "none") then			
			owner = faction
		end
	end
	
	if (owner == "monster") then
		owner = "none"
	end

	smart.defense_count = squadCount[owner] or 0
	smart.defense_power = squadPowers[owner] or 0
	
	if owner ~= "none" then
	   smart.last_last_owner = owner
	end
	
	if not (smart.last_owner) then
		smart.last_owner = owner
	end
	
	if (smart.last_owner ~= smart.owning_faction) then
	    sim_offline_to_online.switch_control_news (smart) 
		--[[if (smart.target_smarts) then		
			smart:hide()
		--	smart.target_smarts = {}
			smart:show()			
		--end]]
	end
	
	if (smart.last_owner) then
		smart.last_owner = smart.owning_faction
	end

	smart.owning_faction = owner	
--[[	
	if owner and owner ~= "none" and owner ~= "monster" then
		if sim_factions.faction_information[owner].total_power > 500 and owner ~= smart.last_owner then
			sim_factions.faction_information[owner].total_power = sim_factions.faction_information[owner].total_power - 500
		else
			sim_factions.faction_information[owner].total_power = 0
		end
	end
]]--	
end

function remove_spot(smart)
	level.map_remove_object_spot(smart.id, sim_tables.pda_icons[smart.simulation_spot])
	level.map_remove_object_spot(smart.id, "base_friend")
	level.map_remove_object_spot(smart.id, "base_enemy")
	level.map_remove_object_spot(smart.id, "base_neutral")
	level.map_remove_object_spot(smart.id, "base_empty")
	level.map_remove_object_spot(smart.id, "lair_friend")
	level.map_remove_object_spot(smart.id, "lair_enemy")
	level.map_remove_object_spot(smart.id, "lair_neutral")
	level.map_remove_object_spot(smart.id, "lair_empty")
	level.map_remove_object_spot(smart.id, "res_friend")
	level.map_remove_object_spot(smart.id, "res_enemy")
	level.map_remove_object_spot(smart.id, "res_neutral")
	level.map_remove_object_spot(smart.id, "res_empty")
end

function show_smart(smart)
	local tg = time_global()
	
	if not smart.last_update then
		smart.last_update = tg + 1000
	end
	
	if tg < smart.last_update then return end
	
	smart.last_update = tg + 1000
	
	if hide_sim == true then
		hide_smart(smart)
		return
	else		
		local faction = smart.owning_faction
		local friend = game_relations.is_factions_friends(sim_brain.actor_faction, faction) or sim_brain.actor_faction == faction
		local enemy = game_relations.is_factions_enemies(sim_brain.actor_faction, faction)
		local neutral = not(game_relations.is_factions_enemies(sim_brain.actor_faction, faction) or game_relations.is_factions_friends(sim_brain.actor_faction, faction))
		
		if (smart.simulation_spot) then
			if (smart.simulation_spot ~= faction) then
				remove_spot(smart)				
				if smart.props.base > 0 then
					if faction ~= "none" then
						if friend then
							if smarts == true then
								level.map_add_object_spot(smart.id, "base_friend", friend_info(smart))
							else
								level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], friend_info(smart))
							end
						elseif enemy then
							if smarts == true then
								level.map_add_object_spot(smart.id, "base_enemy", enemy_info(smart))
							else
								level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], enemy_info(smart))
							end
						elseif neutral then
							if smarts == true then
								level.map_add_object_spot(smart.id, "base_neutral", neutral_info(smart))
							else
								level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], neutral_info(smart))
							end
							
						end
					else
						if smarts == true then
							level.map_add_object_spot(smart.id, "base_empty", none_info(smart))
						else
							level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], none_info(smart))
						end
					end
				elseif smart.props.resource > 0 then
					if faction ~= "none" then
						if friend then
							if smarts == true then
								level.map_add_object_spot(smart.id, "res_friend", friend_info(smart))
							else
								level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], friend_info(smart))
							end
						elseif enemy then
							if smarts == true then
								level.map_add_object_spot(smart.id, "res_enemy", enemy_info(smart))
							else
								level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], enemy_info(smart))
							end
						elseif neutral then
							if smarts == true then
								level.map_add_object_spot(smart.id, "res_neutral", neutral_info(smart))
							else
								level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], neutral_info(smart))
							end
						end
					else
						if faction == "none" then
							if smarts == true then
								level.map_add_object_spot(smart.id, "res_empty", none_info(smart))
							else
								level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], none_info(smart))
							end	
						end
					end
				elseif smart.props.lair > 0 then
					if friend and faction ~= "none" then
						if smarts == true then
							level.map_add_object_spot(smart.id, "lair_friend", friend_info(smart))
						else
							level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], friend_info(smart))
						end						
					end
				end
				smart.simulation_spot = faction
			else
				if smart.props.base > 0 then
					if faction ~= "none" then
						if friend then
							if smarts == true then
								level.map_change_spot_hint(smart.id, "base_friend", friend_info(smart))
							else
								level.map_change_spot_hint(smart.id, sim_tables.pda_icons[faction], friend_info(smart))
							end
						elseif enemy then
							if smarts == true then
								level.map_change_spot_hint(smart.id, "base_enemy", enemy_info(smart))
							else
								level.map_change_spot_hint(smart.id, sim_tables.pda_icons[faction], enemy_info(smart))
							end
						elseif neutral then
							if smarts == true then
								level.map_change_spot_hint(smart.id, "base_neutral", neutral_info(smart))
							else
								level.map_change_spot_hint(smart.id, sim_tables.pda_icons[faction], neutral_info(smart))
							end
							
						end
					else
						if smarts == true then
							level.map_change_spot_hint(smart.id, "base_empty", none_info(smart))
						else
							level.map_change_spot_hint(smart.id, sim_tables.pda_icons[faction], none_info(smart))
						end
					end
				elseif smart.props.resource > 0 then
					if faction ~= "none" then
						if friend then
							if smarts == true then
								level.map_change_spot_hint(smart.id, "res_friend", friend_info(smart))
							else
								level.map_change_spot_hint(smart.id, sim_tables.pda_icons[faction], friend_info(smart))
							end
						elseif enemy then
							if smarts == true then
								level.map_change_spot_hint(smart.id, "res_enemy", enemy_info(smart))
							else
								level.map_change_spot_hint(smart.id, sim_tables.pda_icons[faction], enemy_info(smart))
							end
						elseif neutral then
							if smarts == true then
								level.map_change_spot_hint(smart.id, "res_neutral", neutral_info(smart))
							else
								level.map_change_spot_hint(smart.id, sim_tables.pda_icons[faction], neutral_info(smart))
							end
						end
					else
						if faction == "none" then
							if smarts == true then
								level.map_change_spot_hint(smart.id, "res_empty", none_info(smart))
							else
								level.map_change_spot_hint(smart.id, sim_tables.pda_icons[faction], none_info(smart))
							end	
						end
					end
				elseif smart.props.lair > 0 then
					if friend and faction ~= "none" then
						if smarts == true then
							level.map_change_spot_hint(smart.id, "lair_friend", friend_info(smart))
						else
							level.map_change_spot_hint(smart.id, sim_tables.pda_icons[faction], friend_info(smart))
						end						
					end
				end
			end
		else
			if smart.props.base > 0 then
					if faction ~= "none" then
						if friend then
							if smarts == true then
								level.map_add_object_spot(smart.id, "base_friend", friend_info(smart))
							else
								level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], friend_info(smart))
							end
						elseif enemy then
							if smarts == true then
								level.map_add_object_spot(smart.id, "base_enemy", enemy_info(smart))
							else
								level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], enemy_info(smart))
							end
						elseif neutral then
							if smarts == true then
								level.map_add_object_spot(smart.id, "base_neutral", neutral_info(smart))
							else
								level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], neutral_info(smart))
							end
							
						end
					else
						if faction == "none" then
							if smarts == true then
								level.map_add_object_spot(smart.id, "base_empty", none_info(smart))
							else
								level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], none_info(smart))
							end
						end
					end
				elseif smart.props.resource > 0 then
					if faction ~= "none" then
						if friend then
							if smarts == true then
								level.map_add_object_spot(smart.id, "res_friend", friend_info(smart))
							else
								level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], friend_info(smart))
							end
						elseif enemy then
							if smarts == true then
								level.map_add_object_spot(smart.id, "res_enemy", enemy_info(smart))
							else
								level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], enemy_info(smart))
							end
						elseif neutral then
							if smarts == true then
								level.map_add_object_spot(smart.id, "res_neutral", neutral_info(smart))
							else
								level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], neutral_info(smart))
							end
							
						end
					else
						if faction == "none" then
							if smarts == true then
								level.map_add_object_spot(smart.id, "res_empty", none_info(smart))
							else
								level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], none_info(smart))
							end	
						end
					end
				elseif smart.props.lair > 0 then
					if friend and faction ~= "none" then
						if smarts == true then
							level.map_add_object_spot(smart.id, "lair_friend", friend_info(smart))
						else
							level.map_add_object_spot(smart.id, sim_tables.pda_icons[faction], friend_info(smart))
						end						
					end
				end
			smart.simulation_spot = faction
		end
	end
end

function hide_smart(smart)
	if (smart.simulation_spot) then
		level.map_remove_object_spot(smart.id, sim_tables.pda_icons[smart.simulation_spot])	
		smart.simulation_spot = nil
	end
end
