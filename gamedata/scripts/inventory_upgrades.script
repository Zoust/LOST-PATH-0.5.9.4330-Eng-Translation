---------------------------------------------------------------------------------------------
--' funtions for upgrade items ----------------------------------------------------
--' Made by Distemper ----------------------------------------------------------------
--' 03.08 --------------------------------------------------------------------------------
-- Altered by Alundaio to allow npc to keep items for an amount of time

--------------------------------------------------------------------------------------------
	--' функция доступности апгрейда
		--' function precondition_functor_a( param1, section )
	--' функция применения апгрейда (отнимание у ГГ денег и требуемых материалов)
		--' function effect_functor_a( param2, section )
	--' функция отображения причин, по которым апгрейд недоступен (в описании)
		--' function prereq_functor_a( param3, section )
	--' Функция вывода необходимой для установки суммы денег и материалов (в заголовке)
		--' function get_upgrade_cost( section )
	--' функции для отображения свойств апгрейдов
		--' function property_functor_a( param1, name )
		--' function property_functor_b( param1, name )
		--' function property_functor_c( param1, name )
		--'	function property_functor_d( param1, name )
--------------------------------------------------------------------------------------------

cur_hint = nil
local char_ini = ini_file("item_upgrades.ltx")
local param_ini = ini_file("misc\\stalkers_upgrade_info.ltx")
local cur_price_percent = 1

local RepairItemList = {}
local weapon_upgrades = {}
local effect_funct

local mode = "money"

local d

function on_game_start()
	RegisterScriptCallback("on_key_press",keyboard)
end

function keyboard(dik, keyboard_action)
	if dik == DIK_keys.DIK_X then
		
		if mode == "money" then 
			mode = "material"
			--printf("%s", mode)
		elseif mode == "material" then 
			mode = "money"
			--printf("%s", mode) 
		end
	end
end

function save_state(m_data)
	--alun_utils.debug_write("inventory_upgrades.save_state")
	m_data.RepairItemList = RepairItemList
end

function load_state(m_data)
	RepairItemList = m_data.RepairItemList or RepairItemList
	m_data.RepairItemList = nil
end

----------- Dialog Func--------------------

function lend_item_for_repair(itm,mechanic_name,rt)
	local npc = get_story_object(mechanic_name)
	if (npc) then
		db.actor:transfer_item(itm,npc)
		give_info(npc:section().."_is_repairing")
		news_manager.relocate_item(db.actor, "out", itm:section(), 1)

		if not (RepairItemList[mechanic_name]) then
			RepairItemList[mechanic_name] = {}
		else
			for id,t in pairs(RepairItemList[mechanic_name]) do
				if (t.gt ~= nil) then
					rt = rt + utils.clamp(t.rt - game.get_game_time():diffSec(t.gt),0,t.rt)
				end
			end
		end

		--printf("mechanic name = %s [sec = %s, id = %s]  repair_time = %s",mechanic_name,itm:section(),itm:id(),rt)
		RepairItemList[mechanic_name][itm:id()] = {gt = game.get_game_time(), rt = rt}

		local hud = get_hud()
		if (hud) then
			hud:HideActorMenu()
			--hud:UpdateActorMenu()
		end
	end
end

function has_repair_info(a,b)
	local npc = dialogs.who_is_npc(a,b)
	if (has_alife_info(npc:section().."_is_repairing")) then
		return true
	end
	return false
end

function has_repaired_items(a,b)
	local npc = dialogs.who_is_npc(a,b)
	local sec = npc:section()
	if not (RepairItemList[sec]) then
		return false
	end
	for id,t in pairs(RepairItemList[sec]) do
		if (game.get_game_time():diffSec(t.gt) >= t.rt) then
			return true
		end
	end
	return false
end

function dont_has_repaired_items(a,b)
	local npc = dialogs.who_is_npc(a,b)
	local sec = npc:section()
	if not (RepairItemList[sec]) then
		return true
	end
	for id,t in pairs(RepairItemList[sec]) do
		if (game.get_game_time():diffSec(t.gt) >= t.rt) then
			return false
		end
	end
	return true
end

function give_repaired_items(a,b)
	local npc = dialogs.who_is_npc(a,b)
	local sec = npc:section()
	if not (RepairItemList[sec]) then
		return false
	end

	local process_list = {}
	local itm
	local index = 0
	for id,t in pairs(RepairItemList[sec]) do
		index = index + 1
		if (game.get_game_time():diffSec(t.gt) >= t.rt) then
			itm = level.object_by_id(id)
			if (itm) then
				npc:transfer_item(itm,db.actor)
				news_manager.relocate_item(db.actor, "in", itm:section(), 1)
				process_list[id] = index
				table.insert(process_list,id)
			end
		end
	end

	for i=1,#process_list do
		RepairItemList[sec][process_list[i]] = nil
	end

	disable_info(npc:section().."_is_repairing")

	for k,v in pairs(RepairItemList[sec]) do
		if (k) then
			give_info(npc:section().."_is_repairing")
			break
		end
	end

	return true
end

function dm_repair_not_done(a,b)
	local npc = dialogs.who_is_npc(a,b)
	local sec = npc:section()
	if not (RepairItemList[sec]) then
		return "ERROR in dm_repair_not_done [RepairItemList["..sec.."] = nil"
	end

	local lowest,itm_id,gts
	for id,t in pairs(RepairItemList[sec]) do
		gts = t.rt - game.get_game_time():diffSec(t.gt)
		if not (lowest) then
			lowest = gts
			itm_id = id
		end

		if (gts < lowest) then
			lowest = gts
			itm_id = id
		end
	end

	if (lowest and itm_id) then
		local seconds = lowest
		local minutes = seconds/60
		local hours = minutes/60

		local itm = level.object_by_id(itm_id)
		local itm_sec = itm and itm:section()

		local inv_name = game.translate_string(system_ini():r_string_ex(itm_sec,"inv_name") or "")

		-- TODO: replace with translatable strings
		local text = {}
		for i=1,9 do 
			table.insert(text,"st_inventory_upgrade_reply_"..i)
		end

		local function set_text(str,...)
			local p = {...}
			local i = 0
			local function sr(a)
				i = i + 1
				return tostring(p[i])
			end
			return string.gsub(str,"%%s",sr)
		end

		if (hours < 1) then
			local m = math.floor(minutes)
			if (m <= 1) then
				return set_text(game.translate_string(text[9]))
			end

			if (npc:section() == "zat_a2_stalker_mechanic") then
				return set_text(game.translate_string(text[math.random(3)]),inv_name,m)
			end
			return set_text(game.translate_string(text[math.random(2)]),inv_name,m)
		elseif (hours < 2) then
			local m = math.floor(minutes - 60)
			if (npc:section() == "zat_a2_stalker_mechanic") then
				return set_text(game.translate_string(text[math.random(3,#text)]),inv_name,m)
			end
			return set_text(game.translate_string(text[7]),inv_name,m)
		else
			local h = math.floor(hours)
			local m = math.floor(minutes - (60*h))
			return set_text(game.translate_string(text[8]),inv_name,h,m)
		end
	end
	return "ERROR in dm_repair_not_done no itm_id"
end
----------- End Dialog Func--------------------

function precondition_functor_a( param1, section )
	local actor = db.actor
	local victim = victim_id and (db.storage[victim_id] and db.storage[victim_id].object or level.object_by_id(victim_id))
	if not (victim) then 
		return 2 
	end
	
	local mechanic_name = victim:section()
	
	local ret = 0
	if(param_ini:line_exist(mechanic_name.."_upgr", section)) then
		local param = param_ini:r_string_ex(mechanic_name.."_upgr", section)
		if(param) then
			if(param=="false") then
				ret = 1
			elseif(param~="true") then
				local possibility_table = xr_logic.parse_condlist(victim, mechanic_name.."_upgr", section, param)
				local possibility = xr_logic.pick_section_from_condlist(actor, victim, possibility_table)
				if not(possibility) or (possibility=="false") then
					ret = 2
				end
			end
		end
	end
	
	if not (actor) then -- needed
		return ret 
	end
	
	--return ret

	if actor then		
		-- Проверяем наличие необходимой суммы
		local price = math.floor(char_ini:r_u32(section, "cost")*cur_price_percent)
		d = math.floor(price / 250) 
		
		if d < 1 then d = 1 end
		
		local cash = actor:money()
		local inv_mat = check_count(actor, victim, "materials_up")
		
		if mode == "money" and cash < price then
			return 2
		elseif mode == "material" and inv_mat < d then
			--printf("%s %s", inv_mat, d)
			return 2
		end
		
		
		-- Проверяем наличие необходимых материалов
		-- Читаем материалы, необходимые для установки
		local required_materials = read_string_from_section(section, "required_materials")
		-- Если список материалов не пуст, то
		if required_materials then
			-- Читаем количество необходимых материалов каждого типа
			local required_materials_count = read_string_from_section(section, "required_materials_count")
			if required_materials_count then
				-- Распарсируем строку количества
				required_materials_count = utils.parse_names(required_materials_count)
			end
			-- Распарсируем список материалов
			required_materials = utils.parse_names(required_materials)
			-- Проверяем, есть ли у ГГ каждый нужный объект из списка
			for i = 1, #required_materials do
				local count = 1
				if required_materials_count and required_materials_count[i] then
					count = tonumber(required_materials_count[i])
				end
				-- Если хотя бы одного объекта недостаточно, то делаем апгрейд недоступным
				if not check_for_have_items(actor, required_materials[i], count) and required_materials[i]~="ammo_gauss" and required_materials[i]~="ammo_gauss_cardan" then
					return 2
				-- Иначе смотрим на название секции требуемого материала
				-- Если название секции - аккумулятор, то проверяем необходимое количество зарядов
				elseif required_materials[i]=="ammo_gauss" and (not check_for_actor_has_battery(1, count) or not actor:object("ammo_gauss")) then
					return 2
				elseif required_materials[i]=="ammo_gauss_cardan" and (not check_for_actor_has_battery(2, count) or not actor:object("ammo_gauss_cardan")) then
					return 2
				elseif required_materials[i]=="material_cable" and (not check_for_actor_has_battery(3, count) or not actor:object("material_cable")) then
					return 2
				end
			end
		end
	end
	return ret
end

function effect_functor_a( param2, section, loading ) --( string, string, int )
	if loading == 0 then
		local money = char_ini:r_u32(section, "cost")
		local mat = d
		local actor = db.actor
		local victim = victim_id and (db.storage[victim_id] and db.storage[victim_id].object or level.object_by_id(victim_id))
		if mode == "money" then
			actor:give_money(math.floor(money*-1*cur_price_percent))
		elseif mode == "material" then
			--printf("%s", mat)
			remove_item_count(actor, "materials_up", mat)
		end
		-- Обновляем переменные защиты в слотах
		mod_flags.last_update_time_1=time_global()
		mod_flags.last_outfit_in_slot=nil
		mod_flags.last_helm_in_slot=nil
		-- Читаем материалы, необходимые для установки
		local required_materials = read_string_from_section(section, "required_materials")
		-- Если список материалов не пуст, то
		if required_materials then
			-- Читаем количество необходимых материалов каждого типа
			local required_materials_count = read_string_from_section(section, "required_materials_count")
			if required_materials_count then
				-- Распарсируем строку количества
				required_materials_count = utils.parse_names(required_materials_count)
			end
			-- Распарсируем список материалов
			required_materials = utils.parse_names(required_materials)
			for i = 1, #required_materials do
				local count = 1
				if required_materials_count and required_materials_count[i] then
					count = tonumber(required_materials_count[i])
				end
				-- Удаляем объекты из инвентаря
				if required_materials[i]=="ammo_gauss" then
					remove_actor_battery_count(1, count)
				elseif required_materials[i]=="ammo_gauss_cardan" then
					remove_actor_battery_count(2, count)
				elseif required_materials[i]=="material_cable" then
					remove_actor_battery_count(3, count)
				else
					remove_item_count(actor, required_materials[i], count)
				end
			end
		end
		-- Нужно ли скрывать меню после апгрейда?
		if read_bool_from_section(section, "hide_menu") then
			local hud = get_hud()
			hud:HideActorMenu()
		end
	end
end

function get_upgrade_cost(section)
	-- Переменная текста, который будет показан
	local str = "Change the type of payment [X] \\n"
	if db.actor then
		-- Читаем сумму, необходимую для установки
		local price = math.floor(char_ini:r_u32(section, "cost")*cur_price_percent)
		-- Заносим в переменную текста стоимость апгрейда
		if mode == "money" then 
			str = str..game.translate_string("st_upgr_cost")..": "..price.." RU"
		elseif mode == "material" then
			str = str..game.translate_string("st_upgr_mat")..": "..d.." pieces <"..game.translate_string("materials_up_name")..">"
			printf("%s", d)
		end
		-- Читаем материалы, необходимые для установки
		local required_materials = read_string_from_section(section, "required_materials")
		-- Если список материалов не пуст, то
		if required_materials then
			-- Читаем количество необходимых материалов каждого типа
			local required_materials_count = read_string_from_section(section, "required_materials_count")
			-- Заносим в переменную текста строку необходимых материалов (с новой строки)
			str = str.."\\n "..game.translate_string("st_upgr_required_materials")..":\\n"
			-- Распарсируем список материалов
			required_materials = utils.parse_names(required_materials)
			if required_materials_count then
				-- Распарсируем строку количества
				required_materials_count = utils.parse_names(required_materials_count)
			end
			-- Объявляем переменную имени необходимого материала
			local required_material_name
			-- Заносим в строку текста имя каждого материала из списка
			local materials_n = #required_materials
			for i = 1, materials_n do
				local count = ""
				
				if required_materials_count and required_materials_count[i] then
					count = tonumber(required_materials_count[i])
					if count > 1 then
						count = " x"..count
					elseif required_materials[i]=="ammo_gauss" or required_materials[i]=="ammo_gauss_cardan" or required_materials[i]=="material_cable" then
						count = " x1"
					else
						count = ""
					end
				end
				-- Читаем из секции необходимого материала его имя
				if required_materials[i]=="ammo_gauss" or required_materials[i]=="ammo_gauss_cardan" then
					required_material_name = read_string_from_section(required_materials[i], "inv_name_upg")
					-- Заносим в строку текста имя материала и необходимое количество
					str = str.." • "..game.translate_string(required_material_name).." ("..game.translate_string("st_up_charge")..count..")"
				elseif required_materials[i]=="material_cable" then
					required_material_name = read_string_from_section(required_materials[i], "inv_name_short")
					str = str.." • "..game.translate_string(required_material_name).." ("..game.translate_string("st_up_length")..count.." "..game.translate_string("st_up_meter")..")"
				else
					required_material_name = read_string_from_section(required_materials[i], "inv_name")
					str = str.." • "..game.translate_string(required_material_name)..count
				end
				-- Если позиция материала в списке не замыкающая, то ставим в строку разделитель
				if i~=materials_n then
					str = str.."\\n"
				end
			end
		end
	end
	return str
end

function get_possibility_string(mechanic_name, possibility_table)
		local str = ""
	if(cur_hint) then
		for k,v in pairs(cur_hint) do
			str = str.."\\n - "..game.translate_string(v)
		end
	end
	if(str=="") then
		str = " - add hints for this upgrade"
	end
	return str
end

function prereq_functor_a( param3, section )
	local victim = victim_id and (db.storage[victim_id] and db.storage[victim_id].object or level.object_by_id(victim_id))
	if not (victim) then 
		return ""
	end
	
	local mechanic_name = victim:section()
	local str = ""
	if(param_ini:line_exist(mechanic_name.."_upgr", section)) then
		local param = param_ini:r_string(mechanic_name.."_upgr", section)
		if(param) then
			if(param=="false") then
				return str
			else
				cur_hint = nil
				local possibility_table = xr_logic.parse_condlist(victim, mechanic_name.."_upgr", section, param)
				local possibility = xr_logic.pick_section_from_condlist(db.actor, victim, possibility_table)
				if not(possibility) or (possibility=="false") then
					str = str..get_possibility_string(mechanic_name, possibility_table)
				end
			end
		end
	end
	local actor = db.actor
	if actor then
		-- Читаем из секции апгрейда его цену
		local price = math.floor(char_ini:r_u32(section, "cost")*cur_price_percent)
		-- Читаем кол-во бабла у ГГ
		local cash = actor:money()
		local inv_mat = check_count(actor, victim, "materials_up")
		-- Если бабла не хватает, то заносим в список соответствующую строку
		if mode == "money" and cash < price then
			str = str.."\\n - "..game.translate_string("st_upgr_enough_money").."\\n   • "..price-cash.." RU"
		elseif mode == "material" and inv_mat < d then
			str = str.."\\n - "..game.translate_string("st_upgr_enough_materials").."\\n   • "..game.translate_string("materials_up_name").." : "..d-inv_mat.." штук"
			--printf("%s %s", d, inv_mat)
		end
		-- Читаем материалы, необходимые для установки
		local required_materials = read_string_from_section(section, "required_materials")
		-- Если список материалов не пуст, то
		if required_materials then
			local required_materials_count = read_string_from_section(section, "required_materials_count")
			if required_materials_count then
				required_materials_count = utils.parse_names(required_materials_count)
			end
			-- Распарсируем список материалов
			required_materials = utils.parse_names(required_materials)
			-- Объявляем переменную имени необходимого материала
			local required_material_name
			-- Объявляем переменную списка имён недостающих материалов
			local required_material_name_list = ""
			-- Считаем количество элементов в списке требуемых материалов
			local materials_n = #required_materials
			-- Заносим в список имя каждого недостающего материала
			for i = 1, materials_n do
				local count = 1
				if required_materials_count and required_materials_count[i] then
					count = tonumber(required_materials_count[i])
				end
				-- Если секция требуемого материала относится к аккумуляторам, то проверяем наличие нужного числа зарядов
				if required_materials[i]=="ammo_gauss" and (not check_for_actor_has_battery(1, count) or not actor:object("ammo_gauss")) then
					local required_battery_charge_count = count - calculate_actor_battery_charge_count(1)
					required_battery_charge_count = " ("..game.translate_string("st_up_charge").." x"..required_battery_charge_count..")"
					required_material_name = read_string_from_section(required_materials[i], "inv_name")
					required_material_name_list = required_material_name_list.."   • "..game.translate_string(required_material_name)..required_battery_charge_count
					if i~=materials_n then
						required_material_name_list = required_material_name_list.."\\n"
					end
				elseif required_materials[i]=="ammo_gauss_cardan" and (not check_for_actor_has_battery(2, count) or not actor:object("ammo_gauss_cardan")) then
					local required_battery_charge_count = count - calculate_actor_battery_charge_count(2)
					required_battery_charge_count = " ("..game.translate_string("st_up_charge").." x"..required_battery_charge_count..")"
					required_material_name = read_string_from_section(required_materials[i], "inv_name")
					required_material_name_list = required_material_name_list.."   • "..game.translate_string(required_material_name)..required_battery_charge_count
					if i~=materials_n then
						required_material_name_list = required_material_name_list.."\\n"
					end
				elseif required_materials[i]=="material_cable" and (not check_for_actor_has_battery(3, count) or not actor:object("material_cable")) then
					local required_battery_charge_count = count - calculate_actor_battery_charge_count(3)
					required_battery_charge_count = " ("..game.translate_string("st_up_length").." x"..required_battery_charge_count.." "..game.translate_string("st_up_meter")..")"
					required_material_name = read_string_from_section(required_materials[i], "inv_name")
					required_material_name_list = required_material_name_list.."   • "..game.translate_string(required_material_name)..required_battery_charge_count
					if i~=materials_n then
						required_material_name_list = required_material_name_list.."\\n"
					end
				-- Если требуемый материал - не батареи/проводник, но гг НЕ имеет необходимого кол-ва нужного типа предмета, то
				elseif not check_for_have_items(actor, required_materials[i], count) and required_materials[i]~="ammo_gauss" and required_materials[i]~="ammo_gauss_cardan" and required_materials[i]~="material_cable" then
					-- Читаем из секции необходимого материала его имя (короткое)
					required_material_name = read_string_from_section(required_materials[i], "inv_name")
					local required_material_count = count - calculate_item_count(actor, required_materials[i])
					if required_material_count>1 then
						required_material_count = " x"..required_material_count
					else
						required_material_count = ""
					end
					-- Заносим в список недостающих материалов имя текущего материала и недостающее количество
					required_material_name_list = required_material_name_list.."   • "..game.translate_string(required_material_name)..required_material_count
					-- Если позиция материала в списке не замыкающая, то ставим в строку разделитель
					if i~=materials_n then
						required_material_name_list = required_material_name_list.."\\n"
					end
				end
			end
			-- Если список имён недостающих материалов не пуст, то
			if required_material_name_list~="" then
				-- Заносим в переменную текста строку недостающих материалов (с новой строки)
				str = str.."\\n - "..game.translate_string("st_upgr_enough_materials").."\\n"..required_material_name_list
			end
		end
	end
	return str
end

function property_functor_a(param1, name)
	local section_table = utils.parse_names(param1)
	if (#section_table == 0) then 
		return ""
	end
	
	local prop_name = char_ini:r_string_ex(name, "name")
	if(name == "prop_no_buck" or name == "prop_autofire") then
        return game.translate_string(prop_name)
	end
	
	local sysini = system_ini()
	local prop_damage = {}
	local max_protections = {
		["burn_protection"] = sysini:r_float_ex("actor_condition","fire_zone_max_power",1),
		["chemical_burn_protection"] = sysini:r_float_ex("actor_condition","acid_zone_max_power",1),
		["explosion_protection"] = 1,
		["fire_wound_protection"] = sysini:r_float_ex("actor_condition","max_fire_wound_protection",1),
		["radiation_protection"] = sysini:r_float_ex("actor_condition","radio_zone_max_power",1),
		["shock_protection"] = sysini:r_float_ex("actor_condition","electra_zone_max_power",1),
		["strike_protection"] = 1,
		["telepatic_protection"] = sysini:r_float_ex("actor_condition","psi_zone_max_power",1),
		["wound_protection"] = sysini:r_float_ex("actor_condition","max_wound_protection",1)	
	}
	
	local sum = 0
	local str = ""
	local tmp,val
	
	local ini = ini_file("settings\\exo_seva.ltx")
	
	for i=1,#section_table do
		if (name == "prop_night_vision") then
			if (char_ini:line_exist(section_table[i],"nightvision_sect")) then
				val = char_ini:r_float_ex(section_table[i], "value")
				if (val) then
					if (val > sum) then 
						sum = val 
					end
				end
			end
		elseif (name == "prop_restore_bleeding") then
			sum = sum + (char_ini:r_float_ex(section_table[i],"bleeding_restore_speed",0)/0.1*100)
		elseif (name == "prop_restore_health") then
			sum = sum + (char_ini:r_float_ex(section_table[i],"health_restore_speed",0)/0.02*100)
		elseif (name == "prop_power") then
			sum = sum + (char_ini:r_float_ex(section_table[i],"power_restore_speed",0)/sysini:r_float_ex("actor_condition","max_power_restore_speed",0.01)*100)
		elseif (name == "prop_artefact") then
			sum = sum + char_ini:r_float_ex(section_table[i],"artefact_count",0)
		elseif (name == "prop_weightoutfit" or name == "prop_weight") then
			sum = sum + char_ini:r_float_ex(section_table[i],"inv_weight",0)
		elseif (name == "prop_tonnage") then
			sum = sum + char_ini:r_float_ex(section_table[i],"additional_inventory_weight",0)
		elseif (name == "prop_damage") then
			val = math.abs(char_ini:r_float_ex(section_table[i],"hit_fraction_actor") or 0)*100
			prop_damage["hit_fraction_actor"] = prop_damage["hit_fraction_actor"] and prop_damage["hit_fraction_actor"] + val or val
		elseif (name == "prop_wound") then 
			tmp = char_ini:r_float_ex(section_table[i],"wound_protection") or 0
			val = ((1*tmp)/max_protections["wound_protection"] * 100)
			prop_damage["wound_protection"] = prop_damage["wound_protection"] and prop_damage["wound_protection"] + val or val		
		elseif (name == "prop_strike") then 
			tmp = char_ini:r_float_ex(section_table[i],"strike_protection") or 0
			val = ((1*tmp)/max_protections["strike_protection"] * 100)
			prop_damage["strike_protection"] = prop_damage["strike_protection"] and prop_damage["strike_protection"] + val or val		
		elseif (name == "prop_explo") then 
			tmp = char_ini:r_float_ex(section_table[i],"explosion_protection") or 0
			val = ((1*tmp)/max_protections["explosion_protection"] * 100)
			prop_damage["explosion_protection"] = prop_damage["explosion_protection"] and prop_damage["explosion_protection"] + val or val		
		elseif (name == "prop_chem") then
			tmp = char_ini:r_float_ex(section_table[i],"chemical_burn_protection") or 0
			val = ((1*tmp)/max_protections["chemical_burn_protection"] * 100)
			prop_damage["chemical_burn_protection"] = prop_damage["chemical_burn_protection"] and prop_damage["chemical_burn_protection"] + val or val	
		elseif (name == "prop_radio") then
			tmp = char_ini:r_float_ex(section_table[i],"radiation_protection") or 0
			val = ((1*tmp)/max_protections["radiation_protection"] * 100)
			prop_damage["radiation_protection"] = prop_damage["radiation_protection"] and prop_damage["radiation_protection"] + val or val	
		elseif (name == "prop_thermo") then
			tmp = char_ini:r_float_ex(section_table[i],"burn_protection") or 0
			val = ((1*tmp)/max_protections["burn_protection"] * 100)
			prop_damage["burn_protection"] = prop_damage["burn_protection"] and prop_damage["burn_protection"] + val or val	
		elseif (name == "prop_electro") then
			tmp = char_ini:r_float_ex(section_table[i],"shock_protection") or 0
			val = ((1*tmp)/max_protections["shock_protection"] * 100)
			prop_damage["shock_protection"] = prop_damage["shock_protection"] and prop_damage["shock_protection"] + val or val	
		elseif (name == "prop_psy") then
			tmp = char_ini:r_float_ex(section_table[i],"telepatic_protection") or 0
			val = ((1*tmp)/max_protections["telepatic_protection"] * 100)
			prop_damage["telepatic_protection"] = prop_damage["telepatic_protection"] and prop_damage["telepatic_protection"] + val or val	
		elseif (name == "prop_armor") then
			tmp = char_ini:r_float_ex(section_table[i],"fire_wound_protection") or 0
			val = ((1*tmp)/max_protections["fire_wound_protection"] * 100)
			prop_damage["fire_wound_protection"] = prop_damage["fire_wound_protection"] and prop_damage["fire_wound_protection"] + val or val
        elseif (name == "prop_ammo_size") then
            sum = sum + char_ini:r_float_ex(section_table[i],"ammo_mag_size",0)
        elseif (name == "prop_rpm") then
            sum = sum + math.floor(char_ini:r_float_ex(section_table[i],"rpm",0)/10)
		elseif (name == "prop_dispersion") then
			val = char_ini:r_float_ex(section_table[i],"fire_dispersion_base") or 0
			if (val ~= 0) then
				sum = sum + (ui_wpn_params.normalize(val,1.0,0)-100)
			end
		elseif (name == "prop_bullet_speed") then
			val = char_ini:r_float_ex(section_table[i],"bullet_speed") or 0
			if (val ~= 0) then
				local actual_section = "wpn_" .. section_table[i]:gsub("(.*)_","")
				sum = sum + (val/sysini:r_float_ex(actual_section,"bullet_speed",1000)*100)
			end
		elseif (name == "prop_inertion") then 
			val = char_ini:r_float_ex(section_table[i],"control_inertion_factor") or 0
			if (val ~= 0) then
				sum = sum + (ui_wpn_params.normalize(val,3,0)-100)/2
			end
			val = char_ini:r_float_ex(section_table[i],"PDM_disp_base") or 0
			if (val ~= 0) then
				sum = sum + (ui_wpn_params.normalize(val,2.1,0)-100)/2
			end
		elseif (name == "prop_recoil") then
			local actual_section = "wpn_" .. section_table[i]:gsub("(.*)_","")
			val = char_ini:r_float_ex(section_table[i],"zoom_cam_dispersion") or 0
			if (val ~= 0) then
				sum = sum + (100-ui_wpn_params.normalize(val,sysini:r_float_ex(actual_section,"zoom_cam_dispersion",3),0))/2
			end
			val = char_ini:r_float_ex(section_table[i],"cam_dispersion") or 0
			if (val ~= 0) then				
				sum = sum + (100-ui_wpn_params.normalize(val,sysini:r_float_ex(actual_section,"cam_dispersion",3),0))/2
			end
		elseif (name == "prop_reliability") then 
			val = char_ini:r_float_ex(section_table[i],"misfire_start_prob") or 0
			if (val ~= 0) then
				sum = sum + (ui_wpn_params.normalize(val,0.01,0)-100)/3
			end
			val = char_ini:r_float_ex(section_table[i],"misfire_end_prob") or 0
			if (val ~= 0) then
				sum = sum + (ui_wpn_params.normalize(val,0.1,0)-100)/3
			end
			val = char_ini:r_float_ex(section_table[i],"condition_shot_dec") or 0
			if (val ~= 0) then
				sum = sum + (ui_wpn_params.normalize(val,0.005,0)-100)/3
			end
		else
			sum = sum + (char_ini:r_float_ex(section_table[i], "value") or 0)
		end
	end
	
	if (name == "prop_damage" or name == "prop_wound" or name == "prop_strike" or name == "prop_explo" or name == "prop_chem" or name == "prop_radio" or name == "prop_thermo" or name == "prop_electro" or name == "prop_psy" or name == "prop_armor") then
		local str = ""
		for k,v in pairs(prop_damage) do
			if (v > 0) then
				str = str .. string.format("%s +%.f",game.translate_string("ui_inv_outfit_"..k),v) .. "%"
			else
				str = str .. string.format("%s %.f",game.translate_string("ui_inv_outfit_"..k),v) .. "%"
			end
		end
		return str
	elseif (name == "prop_night_vision") then
		if (sum == 1) then
			return game.translate_string(prop_name)
		end
		return game.translate_string(prop_name.."_"..sum)
	end
	
	local val_s
	if (sum > 0) then
		val_s = "+" .. utils.round(sum)
	else 
		val_s = tostring(utils.round(sum))
	end 
	
	if (name == "prop_ammo_size" or name == "prop_artefact") then
		return game.translate_string(prop_name) .. " " .. val_s
    elseif(name == "prop_tonnage") then
        return string.format("%s +%5.2f %s", game.translate_string(prop_name), sum, game.translate_string("st_kg"))
    elseif(name == "prop_weightoutfit" or name == "prop_weight") then
        return string.format("%s %5.2f %s", game.translate_string(prop_name), sum, game.translate_string("st_kg"))
	end
	
	return game.translate_string(prop_name) .. " " .. val_s  .. "%"
end

function property_functor_b( param1, name )
	return issue_property( param1, name )
end

function property_functor_c( param1, name )
	return issue_property( param1, name )
end

-- Таблица свойств
local property_table = {}
-- prop_name - название свойства
-- parameter_caption - строка параметра в секции
-- koeff - множитель
-- use_sign - не использовать знак +
-- parameter_description - строка хараетеристики значения
--|				prop_name				|	=	|		parameter_caption			|	koeff	|use_sign	|parameter_description	|
property_table["prop_restore_health"]		=	{[1]="health_restore_speed",		[2]=10000,	[3]=false,	[4]="ui_inv_per_10sec",}
property_table["prop_restore_bleeding"]		=	{[1]="bleeding_restore_speed",		[2]=10000,	[3]=false,	[4]="ui_inv_per_10sec",}
property_table["prop_power"]				=	{[1]="power_restore_speed",			[2]=1000,	[3]=false,	[4]="ui_inv_per_sec",}
property_table["prop_stamina"]				=	{[1]="power_loss",					[2]=-100,	[3]=true,	[4]="ui_inv_percent",}
property_table["prop_restore_radiation"]	=	{[1]="radiation_restore_speed",		[2]=10000,	[3]=false,	[4]="ui_inv_per_10sec",}
property_table["prop_chem"]					=	{[1]="chemical_burn_protection",	[2]=100,	[3]=false,	[4]="",}
property_table["prop_psy"]					=	{[1]="telepatic_protection",		[2]=200,	[3]=false,	[4]="",}
property_table["prop_radio"]				=	{[1]="radiation_protection",		[2]=200,	[3]=false,	[4]="",}
property_table["prop_thermo"]				=	{[1]="burn_protection",				[2]=100,	[3]=false,	[4]="",}
property_table["prop_electro"]				=	{[1]="shock_protection",			[2]=100,	[3]=false,	[4]="",}
property_table["prop_damage"]				=	{[1]="wound_protection",			[2]=100,	[3]=false,	[4]="",}
property_table["prop_armor"]				=	{[1]="armor_value",					[2]=1,		[3]=false,	[4]="",}
property_table["prop_durability"]			=	{[1]="durability_value",			[2]=1,		[3]=false,	[4]="ui_inv_percent",}
property_table["prop_tonnage"]				=	{[1]="additional_inventory_weight",	[2]=1,		[3]=false,	[4]="st_kg",}
property_table["prop_weightoutfit"]			=	{[1]="inv_weight",					[2]=1,		[3]=false,	[4]="st_kg",}
property_table["prop_weighthelm"]			=	{[1]="inv_weight",					[2]=1,		[3]=false,	[4]="st_kg",}
property_table["prop_weight"]				=	{[1]="inv_weight",					[2]=1,		[3]=false,	[4]="st_kg",}
property_table["prop_artefact"]				=	{[1]="artefact_count",				[2]=1,		[3]=false,	[4]="",}
property_table["prop_max_health"]			=	{[1]="max_health_add",				[2]=100,	[3]=false,	[4]="",}
property_table["prop_jump_speed"]			=	{[1]="jump_speed_add",				[2]=25,		[3]=false,	[4]="",}
property_table["prop_walk_speed"]			=	{[1]="walk_accel_add",				[2]=10,		[3]=false,	[4]="",}
property_table["prop_binoc_weight"]			=	{[1]="inv_weight",					[2]=1,		[3]=false,	[4]="st_kg",}
property_table["prop_ammo_size"]			=	{[1]="ammo_mag_size",				[2]=1,		[3]=false,	[4]="",}
property_table["prop_rpm"]					=	{[1]="rpm",							[2]=1,		[3]=false,	[4]="",}

function property_functor_d(param1, name)
	-- Читаем строку, которая ссылается на имя апгрейда
	local prorerty_name = char_ini:r_string(name, "name")
	-- Преобразуем строку имени в человеческий вид
	local t_prorerty_name = game.translate_string(prorerty_name)
	-- Распарсируем входящую строку с именами используемых секций 
	local section_table = utils.parse_names(param1)
	-- Считаем количество секций
	local section_table_n = #section_table
	-- Если не присоденино ни одной секции или нет данного свойства в таблице,
	if (section_table_n==0) or (not property_table[name]) then
		-- то возвращаем пустую строку
		return ""
	end
	-- Числовое значение, которое будем отображать в свойствах
	local value = 0
	-- Знак
	local sign = " +"
	-- Характеристика значения
	local additional_parameter = game.translate_string(property_table[name][4])
	-- Считываем нужное значение из всех предоставленных секций
	for i = 1,section_table_n do
		-- Из секции считываем нужный параметр и добавляем к уже имеющемуся значению
		value = value + tonumber(char_ini:r_string(section_table[i], property_table[name][1]))
	end
	-- Получившееся значение умножаем на калибровочный множитель из таблицы
	value = value * tonumber(property_table[name][2])
	-- Проверяем знак
	if property_table[name][3] or value<0 then
		sign = " "
	end
	-- Далее будем записывать все характеристики апгрейда в строку
	local str = ""
	-- Если свойство носит характер изменения весовых характеристик,
	if	name=="prop_tonnage"		or
		name=="prop_weightoutfit"	or
		name=="prop_weighthelm"		or
		name=="prop_weight"			or
		name=="prop_binoc_weight"	then
			-- то необходимо отображение значения в виде числа с двумя знаками после запятой
			str = string.format("%s%s%4.2f %s", t_prorerty_name, sign, value, additional_parameter)
	-- Иначе идём по стандартному алгоритму
	else
		-- Округляем получившееся значение
		value = math.floor(value)
		-- Преобразуем получившееся значение в строку вида "[название свойства] [+/-/ ] [значение] [характеристика значения]"
		str = string.format("%s%s%d %s", t_prorerty_name, sign, value, additional_parameter)
	end
	-- Возвращаем получившуюся строку
	return str
end

function need_victim(obj)
	victim = obj
end

function issue_property( param1, name )
	local prorerty_name = char_ini:r_string_ex(name, "name")
	local t_prorerty_name = game.translate_string(prorerty_name)
	local value_table = utils.parse_names(param1)
	local section = value_table[1]
	if section then
		if not char_ini:line_exist(section, "value") or not char_ini:r_string_ex(section, "value") then
			return t_prorerty_name
		end
		local value = char_ini:r_string_ex(section, "value")
		return t_prorerty_name.." "..string.sub(value, 2, -2)
	else
		return t_prorerty_name
	end
end

local function how_much_repair( item_name, item_condition )
	local ltx = system_ini()
	local cost = ltx:r_u32(item_name, "cost")
	local class = ltx:r_string_ex(item_name, "class")
	local factor = 1.65
	local inv_mat = check_count(actor, victim, "materials_up")
	local mat = math.floor(cost / 250)
	
	local t = math.floor( mat * ((1 * (1-item_condition)) / (1 / (1-item_condition))) * factor * cur_price_percent )
	if t < 1 then t = 1 end
	
	if mode == "money" then 
		return math.floor( cost * ((1 * (1-item_condition)) / (1 / (1-item_condition))) * factor * cur_price_percent )
	elseif mode == "material" then
		return t
	end
end

function can_repair_item( item_name, item_condition, mechanic ) --( string, float, string )
	if (item_name=="pri_a17_gauss_rifle") then
		return false
	end
	
	if system_ini():r_string_ex(item_name, "can_repair") == "false" then
		printf("false")
		return false
	end
	
	local actor = db.actor
	local inv_mat = check_count(actor, victim, "materials_up")
	
	local price = how_much_repair( item_name, item_condition )
	
	d = price 
	
	if d < 1 then d = 1 end
	
	if db.actor:money() < price and mode == "money" then
		return false
	elseif mode == "material" and inv_mat < price then
		return false
	end
	
	local obj = db.actor:object(item_name)
	if (obj and IsArtefact(obj)) then 
		return false
	end

	return true
end

function question_repair_item( item_name, item_condition, can, mechanic ) --( string, float, bool, string )
	if(item_name=="pri_a17_gauss_rifle") then
		return game.translate_string("st_gauss_cannot_be_repaired")
	end
	
	if system_ini():r_string_ex(item_name, "can_repair") == "false" then
		return "Technicians can't fix it"
	end
	
	local actor = db.actor
	
	local price = how_much_repair( item_name, item_condition )
	local inv_mat = check_count(actor, victim, "materials_up")
	
	if db.actor:money() < price and mode == "money" then
		return game.translate_string("st_upgr_cost")..": "..price.." RU\\n"..game.translate_string("ui_inv_not_enought_money")..": "..price-db.actor:money().." RU"
	elseif mode == "material" and inv_mat < price then
		return game.translate_string("st_upgr_cost")..": "..price.." pieces\\n"..game.translate_string("ui_inv_not_enought_money")..": "..price-inv_mat.." pieces"
	end
	
	if db.actor:money() >= price and mode == "money" then
		return game.translate_string("st_upgr_cost").." "..price.." RU. "..game.translate_string("ui_st_inv_repair").."?"
	elseif mode == "material" and inv_mat >= price then
		printf("%s %s %s", inv_mat, d, price)
		return game.translate_string("st_upgr_cost").." "..price.." pieces. "..game.translate_string("ui_st_inv_repair").."?"
	end
end

function effect_upgrade_item(item,upgrade_section) -- Alundaio: called from engine (UIInventoryUpgradeWnd.cpp)
	if (axr_main.config:r_value("mm_options","enable_mechanic_feature",1,false) ~= true) then 
		return
	end
	
	local victim = victim_id and (db.storage[victim_id] and db.storage[victim_id].object or level.object_by_id(victim_id))
	if (victim) then
		lend_item_for_repair(item,victim:section(),1500)
	end
end 

function effect_repair_item( item_name, item_condition)
	local price = how_much_repair( item_name, item_condition )
	local inv_mat = check_count(actor, victim, "materials_up")
	local actor = db.actor
	
	d = price 
	
	if d < 1 then d = 1 end
	
	if mode == "money" then
		db.actor:give_money(-price)
	elseif mode == "material" then
		remove_item_count(actor, "materials_up", d)
	end

	if (axr_main.config:r_value("mm_options","enable_mechanic_feature",1,false) ~= true) then 
		return
	end

	local item
	local function itr(actor,itm)
		if (itm and itm:section() == item_name and itm:condition() == item_condition) then
			item = itm
			return true
		end
		return false
	end

	db.actor:iterate_inventory(itr,db.actor)

	if (item) then
		local victim = victim_id and (db.storage[victim_id] and db.storage[victim_id].object or level.object_by_id(victim_id))
		if (victim) then
			lend_item_for_repair(item,victim:section(),1500)
		end
	end
end

function can_upgrade_item( item_name, mechanic )
	local victim = victim_id and (db.storage[victim_id] and db.storage[victim_id].object or level.object_by_id(victim_id))
	if not (victim) then 
		return 
	end
		
	local mechanic_name = victim:section()
	if param_ini:line_exist(mechanic_name, "discount_condlist") then
		local condlist = param_ini:r_string_ex(mechanic_name, "discount_condlist")
		local parsed = xr_logic.parse_condlist(db.actor, nil, nil, condlist)
		xr_logic.pick_section_from_condlist(db.actor, nil, parsed)
	end
	return true
end

function mech_discount(perc)
	cur_price_percent = perc
end
